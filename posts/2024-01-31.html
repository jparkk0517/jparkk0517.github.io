<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="DOM"/><meta property="og:description" content="Document Object Model에 대한 공부"/><meta name="next-head-count" content="6"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><link rel="preload" href="/_next/static/css/d8e8c40d3ba5a123.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d8e8c40d3ba5a123.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7f71bf29051388fb.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-a7bdc51c2c26039c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e98ecf209ef243c3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-92483e562f8cb0f5.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/29-526565c70891255e.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-1a97b624337d0c98.js" defer="" crossorigin=""></script><script src="/_next/static/9mTlSk8cZ0SRRmV817NDS/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/9mTlSk8cZ0SRRmV817NDS/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar sticky top-0 z-10 bg-base-100"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div class="flex rounded-l-xl rounded-r-none border-2 border-r-0 border-base-300"><input class="input join-item input-sm h-[30px] max-w-[30vw] focus:border-none focus:outline-none" placeholder="" value=""/><span class="mr-2 cursor-pointer"><svg class="h-full w-4 text-gray-600" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M6 18L18 6M6 6l12 12"></path></svg></span></div></div><select class="join-item select select-bordered select-sm h-[34px] border-2 focus:outline-none"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm h-[34px]">조회</button></div></div></div></div></div><main class="prose h-[95vh] overflow-y-scroll p-4 align-baseline"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">DOM</h1><p class="my-4">2024.01.31</p><div class="mb-4 max-w-[80vw] break-words">Document Object Model에 대한 공부</div><div class="badge badge-outline mr-1">DOM</div><div class="badge badge-outline mr-1">Document Object Model</div></div></div></div><div class="divider"></div><div class="min-h-[58vh] max-w-[100vw] bg-white px-6"><h1>노드</h1>
<blockquote>
<p>HTML요소와 노드 객체</p>
</blockquote>
<ul>
<li>HTML요소 : HTML문서를 구성하는 개별 요소<ul>
<li>HTML요소의 구조<ul>
<li>시작태그(start tag)</li>
<li>어트리뷰트 명 (attribute name)</li>
<li>어트리뷰트 값 (attribute value)</li>
<li>콘텐츠 (contents)</li>
</ul>
</li>
</ul>
</li>
<li>HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.</li>
</ul>
<blockquote>
<p>노드 타입의 종류</p>
</blockquote>
<ul>
<li>문서 노드( document node )<ul>
<li>DOM트리 최상에 존재하는 루트 노드</li>
<li>document 객체를 가리킨다.</li>
</ul>
</li>
<li>요소 노드 (element node)<ul>
<li>HTML요소를 가리키는 객체</li>
</ul>
</li>
<li>어트리뷰트 노드 (attribute node)<ul>
<li>HTML요소의 attribute를 가리키는 객체</li>
<li>HTML 요소 노드의 sibling관계를 갖는다.</li>
<li>부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.</li>
</ul>
</li>
<li>텍스트 노드 (text node)<ul>
<li>element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드</li>
</ul>
</li>
</ul>
<blockquote>
<p>노드 객체의 상속구조</p>
</blockquote>
<p>노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.</p>
<p>노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.</p>
<p><img src="/posts/2024-01-31/240203-210458.png" alt="240203-210458"></p>
<p>그림. 노드객체의 상속구조(구글 검색)</p>
<p>위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.</p>
<p>이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.</p>

    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
<span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;input&#x27;</span>);
<span class="hljs-comment">/*
    최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위
*/</span></code>
      </pre>
    </div>
  <blockquote>
<p>Element node의 텍스트 조작</p>
</blockquote>
<ol>
<li><p>nodeValue</p>
<ol>
<li>nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.</li>
</ol>

    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
&lt;div id=<span class="hljs-string">&#x27;text&#x27;</span>&gt;hello&lt;/div&gt;;
<span class="hljs-keyword">const</span> hello = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#text&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hello.<span class="hljs-property">nodeValue</span>); <span class="hljs-comment">// null</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hello.<span class="hljs-property">firstChild</span>.<span class="hljs-property">nodeValue</span>); <span class="hljs-comment">// hello</span></code>
      </pre>
    </div>
  </li>
<li><p>textContent</p>
<ol>
<li><p>getter와 setter가 모두 존재하는 접근자 프로퍼티.</p>
</li>
<li><p>textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)</p>
</li>
<li>
    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
&lt;div id=<span class="hljs-string">&#x27;text&#x27;</span>&gt;
  hello &lt;span&gt;world&lt;/span&gt;
&lt;/div&gt;;
<span class="hljs-keyword">const</span> hello = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#text&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hello.<span class="hljs-property">textContent</span>); <span class="hljs-comment">// hello world</span></code>
      </pre>
    </div>
  </li>
<li><p>element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.</p>
</li>
<li><p>innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.</p>
<ol>
<li>innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.</li>
<li>css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.</li>
</ol>
</li>
</ol>
<blockquote>
<p>어트리뷰트</p>
</blockquote>
<p>HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.</p>
<ul>
<li>HTML어트리뷰트 vs DOM프로퍼티<ul>
<li>어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.</li>
<li>따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.</li>
<li><img src="/posts/2024-01-31/240203-210509.png" alt="240203-210509"></li>
<li>DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!</li>
</ul>
</li>
<li>HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계<ul>
<li>id attribute 와 id property 는 1대1대응</li>
<li>value attribute ⇒ 초깃값, value property ⇒ 최신값</li>
<li>class attribute ⇒ className, classList와 대응</li>
<li>for attribute ⇒ htmlFor 프로퍼티와 1대1 대응</li>
<li>td요소의 colspan attribute는 대응하는 프로퍼티 없음</li>
<li>textContent 프로퍼티는 대응하는 어트리뷰트 없음</li>
<li>attribute는 대소문자x, property는 카멜케이스</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1>레퍼런스</h1>
<ol>
<li>모던 자바스크립트 deep dive(p.677)</li>
</ol>
</div><div class="mt-10 flex max-w-[100vw] justify-between"><button class="btn gap-2 md:btn-md lg:gap-3  w-[48%]"><svg class="size-6 fill-current md:size-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><span class="w-[70%] overflow-hidden text-xs">V8엔진 구동 순서</span></button><button class="btn gap-2 md:btn-md lg:gap-3  w-[48%]"><span class="w-[70%] overflow-hidden  text-xs">Rail 모델</span><svg class="size-6 fill-current md:size-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><footer class="footer footer-center bg-base-100 p-4 text-base-content"><aside><p>Copyright © 2024 - sun</p></aside></footer><div class="drawer absolute bottom-[5vh] left-5 z-30 w-0"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="w-50 menu min-h-full bg-base-200 p-4 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"prev":{"meta":{"title":"V8엔진 구동 순서","desc":"V8엔진의 구동 순서에 대한 공부","date":"2024.01.30","tags":["V8","AST","브라우저"]},"content":"\n\u003e v8엔진 구동 순서\n\n1. 소스코드 파싱\n2. AST(Abstract Syntax Tree) 추상 구문 트리로 변환 → 컴파일러들이 이용하는 자료구조\n3. 자바스크립트 바이트코드로 변환(인터프리터 Ignition 이용)\n   1. Ignition : v8부터 이용되는 인터프리터로 이전의 Full-codegen(인터프리터)를 대체한다.\n\n      (인터프리터 : 소스코드를 바로 실행하는 환경 )\n4. 바이트 코드 실행\n   1. 자주 사용하는 코드는 TurboFan으로 보내 최적화된 코드로 재컴파일(Optimized Machine Code)\n   2. 사용률이 떨어지면 deoptimized\n5.\n\n\u003e 레퍼런스\n\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n","fileName":"2024-01-30","route":"2024-01-30"},"post":{"meta":{"title":"DOM","desc":"Document Object Model에 대한 공부","date":"2024.01.31","tags":["DOM","Document Object Model"]},"content":"\n# 노드\n\n\u003e HTML요소와 노드 객체\n\n- HTML요소 : HTML문서를 구성하는 개별 요소\n  - HTML요소의 구조\n    - 시작태그(start tag)\n    - 어트리뷰트 명 (attribute name)\n    - 어트리뷰트 값 (attribute value)\n    - 콘텐츠 (contents)\n- HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.\n\n\u003e 노드 타입의 종류\n\n- 문서 노드( document node )\n  - DOM트리 최상에 존재하는 루트 노드\n  - document 객체를 가리킨다.\n- 요소 노드 (element node)\n  - HTML요소를 가리키는 객체\n- 어트리뷰트 노드 (attribute node)\n  - HTML요소의 attribute를 가리키는 객체\n  - HTML 요소 노드의 sibling관계를 갖는다.\n  - 부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.\n- 텍스트 노드 (text node)\n  - element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드\n\n\u003e 노드 객체의 상속구조\n\n노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.\n\n노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.\n\n![240203-210458](/posts/2024-01-31/240203-210458.png)\n\n그림. 노드객체의 상속구조(구글 검색)\n\n위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.\n\n이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.\n\n```jsx\nconst input = document.createElement('input');\n/*\n\t최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위\n*/\n```\n\n\u003e Element node의 텍스트 조작\n\n1. nodeValue\n\n   1. nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.\n\n   ```jsx\n   \u003cdiv id='text'\u003ehello\u003c/div\u003e;\n   const hello = document.querySelector('#text');\n   console.log(hello.nodeValue); // null\n   console.log(hello.firstChild.nodeValue); // hello\n   ```\n\n2. textContent\n\n   1. getter와 setter가 모두 존재하는 접근자 프로퍼티.\n   2. textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)\n   3. ```jsx\n      \u003cdiv id='text'\u003e\n        hello \u003cspan\u003eworld\u003c/span\u003e\n      \u003c/div\u003e;\n      const hello = document.querySelector('#text');\n      console.log(hello.textContent); // hello world\n      ```\n\n   4. element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.\n   5. innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.\n      1. innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.\n      2. css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.\n\n   \u003e 어트리뷰트\n\n   HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.\n\n   - HTML어트리뷰트 vs DOM프로퍼티\n     - 어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.\n     - 따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.\n     - ![240203-210509](/posts/2024-01-31/240203-210509.png)\n     - DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!\n   - HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계\n     - id attribute 와 id property 는 1대1대응\n     - value attribute ⇒ 초깃값, value property ⇒ 최신값\n     - class attribute ⇒ className, classList와 대응\n     - for attribute ⇒ htmlFor 프로퍼티와 1대1 대응\n     - td요소의 colspan attribute는 대응하는 프로퍼티 없음\n     - textContent 프로퍼티는 대응하는 어트리뷰트 없음\n     - attribute는 대소문자x, property는 카멜케이스\n     -\n\n# 레퍼런스\n\n1. 모던 자바스크립트 deep dive(p.677)\n","fileName":"2024-01-31","route":"2024-01-31"},"next":{"meta":{"title":"Rail 모델","desc":"브라우저 사용자 경험에 대한 지표 Rail모델","date":"2024.02.01","tags":["Rail","브라우저","렌더링","사용자 경험"]},"content":"\n# Rail 모델\n\n- Rail은 브라우저에서의 성능에 대해 생각할 수 있도록 해주는 사용주 중심 성능 모델\n- 4가지 웹앱의 생명주기를 통해 성능 지표를 나타냄(response, animation, idle, load)\n- 구체적 목표와 지침을 지정하여 성능 측정 항목으로 이용할 수 있도록 함\n\n![240203-210333](/posts/2024-02-01/240203-210333.png)\n\n출처: https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Rail모델에서 바라본 사용자 경험에 대한 기준\n\n| 0~16ms | - 사용자는 초당 60개의 프레임이 렌더링되는걸 부드럽다고 인식한다\n\n- 브라우저에서 새 프레임을 그리는데는 16ms가 걸린다.\n- | 사용자가 애니메이션이 매우 매끄럽다고 느낌 |\n  | ------------------------------------------ | ---------------------------------------------- |\n  | 0~100ms                                    | - 이 정도 응답에선 즉각적 반응이 일어난다 느낌 |\n- 하지만 더 길어지면 동작 ↔ 응답 이 끊어진다는 느낌을 받음 |\n  | 100~1,000ms | - 자연스럽고 지속적 작업의 일부로 받아들일 수 있는 수준\n- 대부분의 웹앱의 상태 |\n  | 1,000ms ~ 10,000ms | - 1초를 초과하므라 사용자는 작업에 집중을 잃게됨 |\n  | 10,000ms 이상 | - 사용자 이탈 |\n\n# Response: 50ms 미만의 이벤트 처리 목표\n\n- 목표 : 사용자 입력에 대한 interaction이 100ms이내에 완료되어 전달 될 수 있도록(즉각적이다는 느낌)\n- 지침\n  - 터치, 스크롤등 연결되는 동작은 제외하고, 클릭, 토글등의 이벤트에 적용\n  - 리소스가 많이 필요한 작업이라면 백그라운드로 동작할 수 있도록(사용자 경험을 차단하지 않도록)\n  - 50ms를 넘기는 응답에 대해선 피드백을 제공할 수 있도록한다.\n\n\u003e 100ms 응답을 위해선 고작 50ms의 여유만 존재한다.\n\n목표가 100ms인 응답을 주려고 할 때, 개발자에게 가용한 시간은 50ms에 불과하다.\n\n목표하는 task처리외에도 입력에 대한 입력을 수용하고, 응답을 표출하기위한 처리시간 또한 필요하므로 실제 사용할 수 있는 시간은 50ms정도!\n\n![240203-210345](/posts/2024-02-01/240203-210345.png)\n\n출처 : https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Animation : 10ms안에 프레임 생성\n\n- 목표\n  - 애니메이션을 각 10ms 프레임 이하로 생성\n  - 각 프레임의 최대예산은 16ms지만 브라우저가 프레임을 렌더링하는 시간이 필요하므로 10ms만 가용\n  - 시각적 부드러움이 목표!\n- 지침\n  - 애니메이션 처리와 같이 높은 연산이 필요한 작업에는 다른 작업을 포함하지 않는다.\n  - 스크롤, 로드표시 와 같은 시각적 애니메이션등을 포함하는 개념들에 적용\n  - 렌더링 성능의 원리는 적극 참조한다.\n\n# Idle: 유휴시간 극대화\n\n- 목표\n  - idle time을 최대화하여 사용자의 입력에 50ms이내 응답할 수 있도록 한다.\n- 지침\n  - 초기 페이지 로드를 가볍게 하고, 유휴 시간에 나머지를 로드하도록 한다.\n  - 50ms를 넘는 작업은 다른 사용자 입력에 대한 응답에 방해가 될 수 있으므로, 그 이내 시간에 할 수 있도록 한다.\n  - 유휴 작업중 사용자 입력이 있다면, 우선순위에 따라 작동하도록 한다.\n\n# Load : 최대 5초 이내 콘텐츠 전달 후 상호작용 준비\n\n- 목표\n  - slow 3g상황에서도 5초 이내에 콘텐츠를 전달하고 상호작용에 준비할 수 있도록 한다.\n- ## 지침\n\n# Rail 측정도구\n\n- chrome devtools\n- Lighthouse\n- WebPageTest\n\n# Referrence\n","fileName":"2024-02-01","route":"2024-02-01"}},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-01-31"},"buildId":"9mTlSk8cZ0SRRmV817NDS","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>