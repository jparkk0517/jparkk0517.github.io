<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({&#x27;gtm.start&#x27;:
new Date().getTime(),event:&#x27;gtm.js&#x27;});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!=&#x27;dataLayer&#x27;?&#x27;&amp;l=&#x27;+l:&#x27;&#x27;;j.async=true;j.src=
&#x27;https://www.googletagmanager.com/gtm.js?id=&#x27;+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,&#x27;script&#x27;,&#x27;dataLayer&#x27;,&#x27;GTM-K5DKF9QN&#x27;);</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="github blog 구축기(4)"/><meta property="og:description" content="marked 라이브러리를 통한 markdown csr"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/e471efda52e68c3f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/e471efda52e68c3f.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f4bb48ce88405231.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-550f72cae410482c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e6e0b507836a963c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-85fa9e6e18f87a53.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/281-ba438958aa97dd96.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-69b4b69adb4f631a.js" defer="" crossorigin=""></script><script src="/_next/static/81J3vCQspJczaQkUNSK_k/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/81J3vCQspJczaQkUNSK_k/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar bg-base-100 sticky top-0 z-10"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div><input class="input input-sm input-bordered join-item max-w-[30vw]" placeholder="" value=""/></div></div><select class="select select-bordered join-item select-sm"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm">조회</button></div></div></div></div></div><main class="prose p-4 align-baseline overflow-y-scroll h-[85vh]"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">github blog 구축기(4)</h1><p class="my-4">2024.02.07</p><div class="max-w-[80vw] break-words mb-4">marked 라이브러리를 통한 markdown csr</div><div class="badge badge-outline mr-1">next.js</div><div class="badge badge-outline mr-1">github blog</div><div class="badge badge-outline mr-1">gh-pages</div><div class="badge badge-outline mr-1">mdx</div><div class="badge badge-outline mr-1">marked</div><div class="badge badge-outline mr-1">highlights</div></div></div></div><div class="divider"></div><div class="markdown-body min-h-[58vh] px-6 max-w-[100vw]"><h1>mdx로 작성한 파일의 정제</h1>
<blockquote>
<p>mdx 작성한 meta 정보를 제거하고싶었다.
하지만 정보 제거에 어려움을 ...ㅠㅠ
next.js 내부에서 모두 해결하고자 했으나, 일단 정적 페이지로 만든 페이지의 경우 SEO 적용도 가능하므로
굳이 여기에 시간 쓰지않고, markdown 문법을 react로 표출할 수 있도록 해주는 라이브러리를 찾기로 결정~!</p>
</blockquote>
<p><img src="/posts/2024-02-07/240208-121859.png" alt="240208-121859">
그림1. markdown 표출에 많이 쓰이는 npm library ( NPM trends )</p>
<p>가장 사용량이 많고, 최근 없데이트가 되는걸로 보이는 marked를 이용하기로 결심</p>
<h2>marked library</h2>
<blockquote>
<p>사용방법이 어렵지 않고, markdown 문법의 문자열을 집어넣어넣고, 그 결과를 innerHTML로 넣으면 간단하게 표출됨을 확인</p>
</blockquote>

    <div class="mockup-code border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
 <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Marked</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;marked&#x27;</span>;
 <span class="hljs-keyword">import</span> { markedHighlight } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;marked-highlight&#x27;</span>;
 <span class="hljs-keyword">import</span> hljs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;highlight.js&#x27;</span>;
 <span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;highlight.js/styles/github.css&#x27;</span>;

 <span class="hljs-keyword">const</span> marked = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Marked</span>(
   <span class="hljs-title function_">markedHighlight</span>({
     <span class="hljs-title function_">highlight</span>(<span class="hljs-params">code, lang</span>) {
       <span class="hljs-keyword">const</span> language = hljs.<span class="hljs-title function_">getLanguage</span>(lang) ? lang : <span class="hljs-string">&#x27;plaintext&#x27;</span>;
       <span class="hljs-keyword">return</span> hljs.<span class="hljs-title function_">highlight</span>(code, { language }).<span class="hljs-property">value</span>;
     },
   })
 );

 <span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> marked.<span class="hljs-title class_">Renderer</span>();

 renderer.<span class="hljs-property">code</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;div class=&quot;mockup-code border bg-[#f6f8fa]&quot; style=&quot;width:90%;margin:auto;margin-bottom:20px;&quot;&gt;&lt;pre style=&quot;margin-bottom:0;padding:0;&quot;&gt;&lt;code&gt;\n${marked.parseInline(code)}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#x27;</span>;
 };

 <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
   <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;markdown-body min-h-[58vh] px-6 max-w-[100vw]&#x27;</span>
   <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span>
     <span class="hljs-attr">__html:</span> <span class="hljs-attr">marked.parse</span>(<span class="hljs-attr">post.content</span>, {
       <span class="hljs-attr">renderer</span>,
     }),
 }}&gt;</span></span></code>
      </pre>
    </div>
  <p>code box 영역에 highlight를 적용하고 daisyUI에서 제공하는 mockup-code 를 활용하고 싶어 위와같이 짰다.
<img src="/posts/2024-02-07/240208-122304.png" alt="240208-122304">
그림2. daisyUI mockup code UI</p>
<p>이렇게 하면 next.js에서 mdx로 작성한 페이지의 meta정보와 별개로 markdown 문법을 내 입맛에 맞게 표출 할 수 있게 되었다.</p>
</div><div class="flex justify-between mt-10 max-w-[100vw]"><button class="btn btn-8xl md:btn-md gap-2 lg:gap-3  w-[48%]"><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><span class="w-[70%] overflow-hidden text-xs">github blog 구축기(3)</span></button><button class="btn btn-8xl md:btn-md gap-2 lg:gap-3 btn-disabled w-[48%]"><span class="w-[70%] overflow-hidden  text-xs"></span><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><div class="drawer absolute left-5 z-30 w-0 bottom-[10vh]"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="menu p-4 w-50 min-h-full bg-base-200 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main><footer class="footer footer-center p-4 bg-base-100 text-base-content w-screen"><aside><p>Copyright © 2024 - sun</p></aside></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"prev":{"meta":{"title":"github blog 구축기(3)","desc":"mdx를 이용한 포스팅 작성","date":"2024.02.06","tags":["next.js","github blog","gh-pages","mdx"]},"content":"\n# 포스팅의 meta정보 입력\n\n- 포스팅의 meta정보를 통해 포스트 리스트 표출시 정보를 표출해야 한다.\n\n![240207-232027](/posts/2024-02-06/240207-232027.png)\n그림1. .mdx 의 meta정보\n\n\u003e getStaticProps로 post가져오기\n\n```typescript\nimport fs from 'fs';\nimport matter from 'gray-matter';\nimport path from 'path';\n\nexport function getPostIds() {\n  const files = fs\n    .readdirSync(path.join('posts'))\n    .filter((filename) =\u003e filename.endsWith('.mdx'))\n    .map((filename) =\u003e filename.replaceAll('.mdx', ''));\n  return files;\n}\n\nexport function getPostById(postId: string) {\n  const markdownWithMeta = fs.readFileSync(\n    path.join('posts', postId + '.mdx'),\n    'utf-8'\n  );\n  const { data: meta, content } = matter(markdownWithMeta);\n  return {\n    meta: {\n      title: meta['title'] ?? '',\n      desc: meta['desc'] ?? '',\n      date: meta['date'] ?? '',\n      tags: meta['tags'] ?? [],\n    },\n    content,\n    fileName: postId,\n    route: postId,\n  };\n}\n\nexport const getStaticProps: GetStaticProps = async ({ params }) =\u003e {\n  const { postId = '' } = params ?? { postId: '' };\n  const postIds = getPostIds();\n  const idx = postIds.findIndex((_postId) =\u003e postId === _postId);\n  let prev = null,\n    post = null,\n    next = null;\n  for (let i = 0; i \u003c postIds.length; i++) {\n    const _postId = postIds[i];\n    if (_postId === postId) {\n      prev = i === 0 ? null : getPostById(postIds[i - 1]);\n      post = getPostById(_postId);\n      next = i + 1 === postIds.length ? null : getPostById(postIds[i + 1]);\n      break;\n    }\n  }\n\n  return {\n    props: {\n      prev,\n      post,\n      next,\n    },\n  };\n};\n```\n\nroot folder에 posts 폴더를 만들고 그 내부에 포스트들을 mdx파일로 생성하고, 그 파일들을 읽도록 했다.\n![240208-020424](/posts/2024-02-06/240208-020424.png)\n그림2. folder 구조 및 posts 폴더\n\n이때 폴더명은 포스트가 작성된 날짜를 기준으로 했고, 그 날짜는 mdx 내부에 적어놓은 meta와 동일하게 맞추었다.\n","fileName":"2024-02-06","route":"2024-02-06"},"post":{"meta":{"title":"github blog 구축기(4)","desc":"marked 라이브러리를 통한 markdown csr","date":"2024.02.07","tags":["next.js","github blog","gh-pages","mdx","marked","highlights"]},"content":"\n# mdx로 작성한 파일의 정제\n\n\u003e mdx 작성한 meta 정보를 제거하고싶었다.\n\u003e 하지만 정보 제거에 어려움을 ...ㅠㅠ\n\u003e next.js 내부에서 모두 해결하고자 했으나, 일단 정적 페이지로 만든 페이지의 경우 SEO 적용도 가능하므로\n\u003e 굳이 여기에 시간 쓰지않고, markdown 문법을 react로 표출할 수 있도록 해주는 라이브러리를 찾기로 결정~!\n\n![240208-121859](/posts/2024-02-07/240208-121859.png)\n그림1. markdown 표출에 많이 쓰이는 npm library ( NPM trends )\n\n가장 사용량이 많고, 최근 없데이트가 되는걸로 보이는 marked를 이용하기로 결심\n\n## marked library\n\n\u003e 사용방법이 어렵지 않고, markdown 문법의 문자열을 집어넣어넣고, 그 결과를 innerHTML로 넣으면 간단하게 표출됨을 확인\n\n```tsx\n import { Marked } from 'marked';\n import { markedHighlight } from 'marked-highlight';\n import hljs from 'highlight.js';\n import 'highlight.js/styles/github.css';\n\n const marked = new Marked(\n   markedHighlight({\n     highlight(code, lang) {\n       const language = hljs.getLanguage(lang) ? lang : 'plaintext';\n       return hljs.highlight(code, { language }).value;\n     },\n   })\n );\n\n const renderer = new marked.Renderer();\n\n renderer.code = function (code: string) {\n   return '\u003cdiv class=\"mockup-code border bg-[#f6f8fa]\" style=\"width:90%;margin:auto;margin-bottom:20px;\"\u003e\u003cpre style=\"margin-bottom:0;padding:0;\"\u003e\u003ccode\u003e\\n${marked.parseInline(code)}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e';\n };\n\n \u003cdiv\n   className='markdown-body min-h-[58vh] px-6 max-w-[100vw]'\n   dangerouslySetInnerHTML={{\n     __html: marked.parse(post.content, {\n       renderer,\n     }),\n }}\u003e\n```\n\ncode box 영역에 highlight를 적용하고 daisyUI에서 제공하는 mockup-code 를 활용하고 싶어 위와같이 짰다.\n![240208-122304](/posts/2024-02-07/240208-122304.png)\n그림2. daisyUI mockup code UI\n\n이렇게 하면 next.js에서 mdx로 작성한 페이지의 meta정보와 별개로 markdown 문법을 내 입맛에 맞게 표출 할 수 있게 되었다.\n","fileName":"2024-02-07","route":"2024-02-07"},"next":null},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-02-07"},"buildId":"81J3vCQspJczaQkUNSK_k","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>