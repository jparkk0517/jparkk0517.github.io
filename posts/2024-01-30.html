<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({&#x27;gtm.start&#x27;:
new Date().getTime(),event:&#x27;gtm.js&#x27;});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!=&#x27;dataLayer&#x27;?&#x27;&amp;l=&#x27;+l:&#x27;&#x27;;j.async=true;j.src=
&#x27;https://www.googletagmanager.com/gtm.js?id=&#x27;+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,&#x27;script&#x27;,&#x27;dataLayer&#x27;,&#x27;GTM-K5DKF9QN&#x27;);</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="V8엔진 구동 순서"/><meta property="og:description" content="V8엔진의 구동 순서에 대한 공부"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/b03d389bba726da9.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/b03d389bba726da9.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d5df541eefd90b90.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-550f72cae410482c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e6e0b507836a963c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-a165a1f7b26ae656.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/281-ba438958aa97dd96.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-f20f668ea71a4913.js" defer="" crossorigin=""></script><script src="/_next/static/psoFYFbA8DMTphf5HtxYr/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/psoFYFbA8DMTphf5HtxYr/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar bg-base-100 sticky top-0 z-10"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div><input class="input input-sm input-bordered join-item max-w-[30vw]" placeholder="" value=""/></div></div><select class="select select-bordered join-item select-sm"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm">조회</button></div></div></div></div></div><main class="prose p-4 align-baseline overflow-y-scroll h-[85vh]"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">V8엔진 구동 순서</h1><p class="my-4">2024.01.30</p><div class="max-w-[80vw] break-words mb-4">V8엔진의 구동 순서에 대한 공부</div><div class="badge badge-outline mr-1">V8</div><div class="badge badge-outline mr-1">AST</div><div class="badge badge-outline mr-1">브라우저</div></div></div></div><div class="divider"></div><article class="markdown-body min-h-[58vh] px-6"><div><blockquote>
<p>v8엔진 구동 순서</p>
</blockquote>
<ol>
<li>소스코드 파싱</li>
<li>AST(Abstract Syntax Tree) 추상 구문 트리로 변환 → 컴파일러들이 이용하는 자료구조</li>
<li>자바스크립트 바이트코드로 변환(인터프리터 Ignition 이용)<ol>
<li><p>Ignition : v8부터 이용되는 인터프리터로 이전의 Full-codegen(인터프리터)를 대체한다.</p>
<p>(인터프리터 : 소스코드를 바로 실행하는 환경 )</p>
</li>
</ol>
</li>
<li>바이트 코드 실행<ol>
<li>자주 사용하는 코드는 TurboFan으로 보내 최적화된 코드로 재컴파일(Optimized Machine Code)</li>
<li>사용률이 떨어지면 deoptimized</li>
</ol>
</li>
<li></li>
</ol>
<blockquote>
<p>레퍼런스</p>
</blockquote>
<ul>
<li><a href="https://evan-moon.github.io/2019/06/28/v8-analysis/">https://evan-moon.github.io/2019/06/28/v8-analysis/</a></li>
</ul>
</div></article><div class="flex justify-between  mt-10"><button class="btn btn-neutral btn-sm md:btn-md gap-2 lg:gap-3 "><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><div class="flex flex-col items-start"><span class="text-base-content/50 hidden text-xs font-normal md:block">Prev</span><span>GraphQL은 무엇인가</span></div></button><button class="btn btn-neutral btn-sm md:btn-md gap-2 lg:gap-3 "><div class="flex flex-col items-end"><span class="text-neutral-content/50 hidden text-xs font-normal md:block">Next</span><span>DOM</span></div><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><div class="drawer absolute left-5 z-30 w-0 bottom-[10vh]"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="menu p-4 w-50 min-h-full bg-base-200 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main><footer class="footer footer-center p-4 bg-base-100 text-base-content w-screen"><aside><p>Copyright © 2024 - sun</p></aside></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"prev":{"meta":{"title":"GraphQL은 무엇인가","desc":"GraphQL에 대한 공부","date":"2024.01.29","tags":["Graph QL","그래프 큐엘"]},"content":"\n\u003e GraphQL이란\n\n\u003caside\u003e\n💡 GraphQL은 쿼리언어이자 서버측 런타임\n\n\u003c/aside\u003e\n\n그래프 큐엘은 데이터를 가져오는데 쿼리를 이용하도록 합니다.\n\n\u003e runtime\n\ngraphQL api는 서버에서 runtime에 실행된다.\n\n데이터의 출처에 구애받지 않고 runtime에 데이터 패칭이 가능하다.\n\n\u003e GraphQL 구현 순서\n\n1. GraphQL schema design\n2. resolver ↔ data source connection\n3. GraphQL query fetching\n\n\u003e GraphQL 의 특징\n\n1. 성능\n   1. 오버패칭 방지\n   2. 언더패칭 방지: rest API의 경우 서로 다른 schema 또는 data source의 경우 여러번의 api콜로 각각 언더패칭된 데이터를 front-side에서 조합해야 하는 경우가 있다. graphQL은 이런 문제를 해결해준다.\n2. 개발자 편의성\n   1. 계층적 스키마 구조: 그래프 구조와 선언적 구조를 통해 쿼리를 직관적으로 이해할 수 있다.\n   2. 타입 안정성: graphQL은 그 자체로 스키마 구조를 가지므로 프론트 사이드와 서버 사이드의 타입이 상호 동일해야만 통신이 가능하므로 그 자체로 타입안정성을 보장한다.\n3. 구조\n   1. 클라이언트 개발의 서버 의존성 분리: restAPI처럼 서버사이드에서 원하는 API를 개발해 줄 때까지 기다려야 하는 업무의존성을 없앨 수 있다.\n   2. 단일 정보출처: 프론트 사이드에선 데이터들 마다 API를 언더패칭하여 조합하던 restAPI와 달리 조합이 되어 불려오도록 하는 단일 출처만 알면된다.\n4. 훌륭한 커뮤니티\n   1. 훌륭한 도구들: apollo client, apollo studio 등 다양한 도구들이 완비되어있다.\n   2. 광범위한 이용: 여러 사이트 들에서 graphQL을 이용중이다.\n","fileName":"2024-01-29","route":"2024-01-29"},"post":{"meta":{"title":"V8엔진 구동 순서","desc":"V8엔진의 구동 순서에 대한 공부","date":"2024.01.30","tags":["V8","AST","브라우저"]},"content":"\n\u003e v8엔진 구동 순서\n\n1. 소스코드 파싱\n2. AST(Abstract Syntax Tree) 추상 구문 트리로 변환 → 컴파일러들이 이용하는 자료구조\n3. 자바스크립트 바이트코드로 변환(인터프리터 Ignition 이용)\n   1. Ignition : v8부터 이용되는 인터프리터로 이전의 Full-codegen(인터프리터)를 대체한다.\n\n      (인터프리터 : 소스코드를 바로 실행하는 환경 )\n4. 바이트 코드 실행\n   1. 자주 사용하는 코드는 TurboFan으로 보내 최적화된 코드로 재컴파일(Optimized Machine Code)\n   2. 사용률이 떨어지면 deoptimized\n5.\n\n\u003e 레퍼런스\n\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n","fileName":"2024-01-30","route":"2024-01-30"},"next":{"meta":{"title":"DOM","desc":"Document Object Model에 대한 공부","date":"2024.01.31","tags":["DOM","Document Object Model"]},"content":"\n# 노드\n\n\u003e HTML요소와 노드 객체\n\n- HTML요소 : HTML문서를 구성하는 개별 요소\n  - HTML요소의 구조\n    - 시작태그(start tag)\n    - 어트리뷰트 명 (attribute name)\n    - 어트리뷰트 값 (attribute value)\n    - 콘텐츠 (contents)\n- HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.\n\n\u003e 노드 타입의 종류\n\n- 문서 노드( document node )\n  - DOM트리 최상에 존재하는 루트 노드\n  - document 객체를 가리킨다.\n- 요소 노드 (element node)\n  - HTML요소를 가리키는 객체\n- 어트리뷰트 노드 (attribute node)\n  - HTML요소의 attribute를 가리키는 객체\n  - HTML 요소 노드의 sibling관계를 갖는다.\n  - 부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.\n- 텍스트 노드 (text node)\n  - element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드\n\n\u003e 노드 객체의 상속구조\n\n노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.\n\n노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.\n\n![240203-210458](/posts/2024-01-31/240203-210458.png)\n\n그림. 노드객체의 상속구조(구글 검색)\n\n위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.\n\n이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.\n\n```jsx\nconst input = document.createElement('input');\n/*\n\t최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위\n*/\n```\n\n\u003e Element node의 텍스트 조작\n\n1. nodeValue\n\n   1. nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.\n\n   ```jsx\n   \u003cdiv id='text'\u003ehello\u003c/div\u003e;\n   const hello = document.querySelector('#text');\n   console.log(hello.nodeValue); // null\n   console.log(hello.firstChild.nodeValue); // hello\n   ```\n\n2. textContent\n\n   1. getter와 setter가 모두 존재하는 접근자 프로퍼티.\n   2. textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)\n   3. ```jsx\n      \u003cdiv id='text'\u003e\n        hello \u003cspan\u003eworld\u003c/span\u003e\n      \u003c/div\u003e;\n      const hello = document.querySelector('#text');\n      console.log(hello.textContent); // hello world\n      ```\n\n   4. element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.\n   5. innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.\n      1. innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.\n      2. css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.\n\n   \u003e 어트리뷰트\n\n   HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.\n\n   - HTML어트리뷰트 vs DOM프로퍼티\n     - 어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.\n     - 따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.\n     - ![240203-210509](/posts/2024-01-31/240203-210509.png)\n     - DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!\n   - HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계\n     - id attribute 와 id property 는 1대1대응\n     - value attribute ⇒ 초깃값, value property ⇒ 최신값\n     - class attribute ⇒ className, classList와 대응\n     - for attribute ⇒ htmlFor 프로퍼티와 1대1 대응\n     - td요소의 colspan attribute는 대응하는 프로퍼티 없음\n     - textContent 프로퍼티는 대응하는 어트리뷰트 없음\n     - attribute는 대소문자x, property는 카멜케이스\n     -\n\n# 레퍼런스\n\n1. 모던 자바스크립트 deep dive(p.677)\n","fileName":"2024-01-31","route":"2024-01-31"}},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-01-30"},"buildId":"psoFYFbA8DMTphf5HtxYr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>