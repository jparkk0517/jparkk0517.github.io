<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="자바스크립트의 실행 컨텍스트"/><meta property="og:description" content="자바스크립트의 소스코드 평가 및 실행에 대한 설명"/><meta name="next-head-count" content="6"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><link rel="preload" href="/_next/static/css/a3380dab395b114b.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/a3380dab395b114b.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-c5490265a50f55a3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-550f72cae410482c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e6e0b507836a963c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-029e80c529502cd5.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/29-bed587a0543d4f84.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-da2083a5df0f2bb7.js" defer="" crossorigin=""></script><script src="/_next/static/aRl6ChvNGBBDWk_Zx37cq/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/aRl6ChvNGBBDWk_Zx37cq/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar sticky top-0 z-10 bg-base-100"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div class="flex rounded-l-xl rounded-r-none border-2 border-r-0 border-base-300"><input class="input join-item input-sm h-[30px] max-w-[30vw] focus:border-none focus:outline-none" placeholder="" value=""/><span class="mr-2 cursor-pointer"><svg class="h-full w-4 text-gray-600" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M6 18L18 6M6 6l12 12"></path></svg></span></div></div><select class="join-item select select-bordered select-sm h-[34px] border-2 focus:outline-none"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm h-[34px]">조회</button></div></div></div></div></div><main class="prose h-[95vh] overflow-y-scroll p-4 align-baseline"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">자바스크립트의 실행 컨텍스트</h1><p class="my-4">2024.01.27</p><div class="mb-4 max-w-[80vw] break-words">자바스크립트의 소스코드 평가 및 실행에 대한 설명</div><div class="badge badge-outline mr-1">자바스크립트</div><div class="badge badge-outline mr-1">javascript</div><div class="badge badge-outline mr-1">context</div><div class="badge badge-outline mr-1">자바스크립트 실행 컨텍스트</div></div></div></div><div class="divider"></div><div class="min-h-[58vh] max-w-[100vw] whitespace-pre-wrap bg-white px-6"><h1 class="border-b-2 font-bold text-5xl mb-5 text-gray-500">실행 컨텍스트</h1><blockquote>
<p>자바스크립트 소스코드의 4가지 타입</p>
</blockquote>
<ol>
<li>소스 코드 : 전역에 존재하는 소스코드( 함수, 클래스동의 내부 코드는 포함되지 않음 )</li>
<li>함수 코드 : 함수 내부에 존재하는 소스코드 ( 중첩 함수, 클래스 등의 코드는 포함되지 않음 )</li>
<li>eval 코드 : eval에 전달되어 실행되는 소스코드</li>
<li>모듈 코드 : 모듈 내부에 존재하는 소스코드 ( 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않음 )</li>
</ol>
<blockquote>
<p>소스 코드</p>
</blockquote>
<p>전역 변수를 관리하기 위한 전역 스코프를 생성하고, 전역변수/함수 선언문 등을 전역 객체의 프로퍼티와 메서드로 바인딩 시킨다.</p>
<blockquote>
<p>함수 코드</p>
</blockquote>
<p>지역 ㅅ코프를 생성하고, 지역변수, 매개변수, arguments객체를 관리한다.</p>
<blockquote>
<p>eval 코드</p>
</blockquote>
<p>strict mode에서 자신만의 스코프를 생성하고 이를통해 실행 컨텍스트가 생성된다.</p>
<blockquote>
<p>모듈 코드</p>
</blockquote>
<p>모듈별 독립적 모듈 스코프를 생성한다.</p>
<p>모듈 코드가 평가되면 모듈의 실행 컨텍스트가 생성된다.</p>
<h1 class="border-b-2 font-bold text-5xl mb-5 text-gray-500">자바스크립트의 소스코드 평가 및 실행</h1><p>자바스크립트의 실행은 크게 두 가지 과정이 있다.</p>
<ol>
<li>소스코드 평가<ol>
<li>소스코드 평가 과정이 실행되면 먼저 실행 컨텍스트를 생성한다.</li>
<li>변수 및 함수의 선언문만 먼저 실행하여 실행 컨텍스트가 관리하는 스코프( 렉시컬 환경 스코프 )에 등록한다.</li>
</ol>
</li>
<li>소스코드의 실행<ol>
<li>소스코드 평가가 완료되면 선언문을 제외한 나머지 소스코드가 순차적으로 실행된다. ( = runtime)</li>
<li>이때 필요한 실행정보(변수 및 함수 값)은 해당 스코프에서 취득한다.</li>
<li>변수나 함수의 변경이 일어나면 해당 스코프의 변수/함수를 수정한다.</li>
</ol>
</li>
</ol>
<h1 class="border-b-2 font-bold text-5xl mb-5 text-gray-500">자바스크립트 실행 컨텍스트의 역할</h1><ol>
<li>전역 코드 평가<ol>
<li>전역변수, 함수선언문을 전역 객체의 프로퍼티 및 메서드로 등록</li>
</ol>
</li>
<li>전역 코드 실행<ol>
<li>함수가 호출되면 전역 코드 실행을 일시 중단하고, 함수 내부로 진입</li>
</ol>
</li>
<li>함수 코드 평가<ol>
<li>함수의 코드를 평가하며 필요한 값들을 함수 내부 스코프에 등록</li>
</ol>
</li>
<li>함수 코드 실행<ol>
<li>함수 코드 평가로 등록된 변수/함수들을 이용하여 코드를 실행한다.</li>
</ol>
</li>
</ol>
</div><div class="mt-10 flex max-w-[100vw] justify-between"><button class="btn gap-2 md:btn-md lg:gap-3 btn-disabled w-[48%]"><svg class="size-6 fill-current md:size-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><span class="w-[70%] overflow-hidden text-xs"></span></button><button class="btn gap-2 md:btn-md lg:gap-3  w-[48%]"><span class="w-[70%] overflow-hidden  text-xs">리액트 쿼리 tkdodo blog 글 번역</span><svg class="size-6 fill-current md:size-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><footer class="footer footer-center bg-base-100 p-4 text-base-content"><aside><p>Copyright © 2024 - sun</p></aside></footer><div class="drawer absolute bottom-[5vh] left-5 z-30 w-0"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="w-50 menu min-h-full bg-base-200 p-4 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"prev":null,"post":{"meta":{"title":"자바스크립트의 실행 컨텍스트","desc":"자바스크립트의 소스코드 평가 및 실행에 대한 설명","date":"2024.01.27","tags":["자바스크립트","javascript","context","자바스크립트 실행 컨텍스트"]},"content":"\n# 실행 컨텍스트\n\n\u003e 자바스크립트 소스코드의 4가지 타입\n\n1. 소스 코드 : 전역에 존재하는 소스코드( 함수, 클래스동의 내부 코드는 포함되지 않음 )\n2. 함수 코드 : 함수 내부에 존재하는 소스코드 ( 중첩 함수, 클래스 등의 코드는 포함되지 않음 )\n3. eval 코드 : eval에 전달되어 실행되는 소스코드\n4. 모듈 코드 : 모듈 내부에 존재하는 소스코드 ( 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않음 )\n\n\u003e 소스 코드\n\n전역 변수를 관리하기 위한 전역 스코프를 생성하고, 전역변수/함수 선언문 등을 전역 객체의 프로퍼티와 메서드로 바인딩 시킨다.\n\n\u003e 함수 코드\n\n지역 ㅅ코프를 생성하고, 지역변수, 매개변수, arguments객체를 관리한다.\n\n\u003e eval 코드\n\nstrict mode에서 자신만의 스코프를 생성하고 이를통해 실행 컨텍스트가 생성된다.\n\n\u003e 모듈 코드\n\n모듈별 독립적 모듈 스코프를 생성한다.\n\n모듈 코드가 평가되면 모듈의 실행 컨텍스트가 생성된다.\n\n# 자바스크립트의 소스코드 평가 및 실행\n\n자바스크립트의 실행은 크게 두 가지 과정이 있다.\n\n1. 소스코드 평가\n   1. 소스코드 평가 과정이 실행되면 먼저 실행 컨텍스트를 생성한다.\n   2. 변수 및 함수의 선언문만 먼저 실행하여 실행 컨텍스트가 관리하는 스코프( 렉시컬 환경 스코프 )에 등록한다.\n2. 소스코드의 실행\n   1. 소스코드 평가가 완료되면 선언문을 제외한 나머지 소스코드가 순차적으로 실행된다. ( = runtime)\n   2. 이때 필요한 실행정보(변수 및 함수 값)은 해당 스코프에서 취득한다.\n   3. 변수나 함수의 변경이 일어나면 해당 스코프의 변수/함수를 수정한다.\n\n# 자바스크립트 실행 컨텍스트의 역할\n\n1. 전역 코드 평가\n   1. 전역변수, 함수선언문을 전역 객체의 프로퍼티 및 메서드로 등록\n2. 전역 코드 실행\n   1. 함수가 호출되면 전역 코드 실행을 일시 중단하고, 함수 내부로 진입\n3. 함수 코드 평가\n   1. 함수의 코드를 평가하며 필요한 값들을 함수 내부 스코프에 등록\n4. 함수 코드 실행\n   1. 함수 코드 평가로 등록된 변수/함수들을 이용하여 코드를 실행한다.\n","fileName":"2024-01-27","route":"2024-01-27"},"next":{"meta":{"title":"리액트 쿼리 tkdodo blog 글 번역","desc":"리액트 쿼리 공식 사이트에 있는 블로그 글을 스터디하여 공유","date":"2024.01.28","tags":["react query","리액트 쿼리"]},"content":"\nApollo Client의 등장으로 fetch library( 데이터 가져오기 라이브러리 )가 redux와 같은 전역 상태관리 라이브러리를 대체할 수 있다는 의견이 확산되었다.\n\n# # 1. 실용적 리액트 쿼리\n\n\u003e 클라이언트 상태 VS 서버 상태\n\nApollo는 data fetching 뿐만 아니라 서버에서 보낸 데이터( fetching해온 서버 데이터 )에 대한 캐시 기능까지 제공한다. 즉 useQuery hook을 사용하여 fetching한 후 캐싱된 데이터를 여러 Component에서 이용할 수 있도록 해준다.\n\n이전의 클라이언트 앱들은 서버의 상태( 표시하고자 하는 데이터 )를 소유하지 않고, 가장 최신의 자료를 가져와서 표출하는데 그치고 있었다. 항상 데이터의 소유자는 서버였다.\n\n\u003e React-Query\n\n리액트 쿼리는 Fronet-end단에서도 data fetching과 loading, error state를 포함한 상태 전역을 단순하게 관리하도록 하고자 했다. REST api처럼\n\nreact-query는 refetchOnWindowFocus를 통해 다른 창에 갔던 focus가 다시 돌아오면 서버에 데이터를 요청하여 최신상태의 데이터를 가져옵니다. 이를 통해 트리거된 Component의 표출된 데이터가 변경되며 이 모든 과정은 loading spinner가 없이 자동으로 이루어집니다.\n\n1. StaleTime: query data가 최신(fresh) → 오래된(stale)상태가 되는데 까지 걸리는 시간을 뜻합니다. 쿼리의 데이터가 최신이라고 판단될 경우 항상 cache에 있는 데이터만을 표출하도록 합니다( 네트워크 요청 없이 )\n2. CacheTime: 비활성 쿼리가 캐시에서 제거 될때까지의 시간을 뜻합니다(default = 5min). 해당 쿼리에 등록된 관찰자(observer)가 없는 경우 즉시 쿼리가 비활성 상태가 됩니다.\n\n⇒ 대부분의 경우 staleTime을 조정하도록하고, cacheTime은 조정할 필요가 거의 없습니다.\n\n# # 2. 리액트 쿼리의 데이터 변환\n\n\u003e 데이터의 변환\n\nREST를 이용하여 데이터를 불러올 때, 화면에 표출하기 위한 형태로 데이터를 가공할 수 있는 지점은 3 + 1군데가 존재한다.\n\n1. back-end ( +1에 해당하며 front-end의 담당이 아닌 구역)\n   1. 백엔드단에서 애초에 필요한 데이터 형태로 가공하여 데이터를 전달해주는 방법\n   2. 장점\n      1. 표출에 완전히 부합하는 형태 그대로 데이터를 받을 수 있다.\n   3. 단점\n      1. 프론트앤드의 영역이 아니다\n2. queryFn\n   1. useQuery(${QUERY_KEY}, ${queryFn})\n      1. 여기서 queryFn을 통해 받아온 데이터를 가공하여 cache에 저장할 수 있다.\n   2. 장점\n      1. 데이터 처리 위치가 백엔드에 가깝다 ( front-end component ↔ cache ↔ back-end )\n   3. 단점\n      1. fetching을 통해 받아온 데이터를 queryFn에서 가공하여 cache에 저장하므로 원래 fetching해온 데이터 원형을 나중에 다시 확인할 수 없다.\n3. Render\n   1. react component render단위에서 해당 데이터를 가공하는 방법\n   2. 장점\n      1. useMemo를 통해 최적화가 가능하다.\n   3. 단점\n      1. 데이터의 정확한 구조를 devtools를 통해 확인하기가 어렵다\n      2. 구문이 복잡하다\n4. 선택 옵션\n   1. useQuery( ${QUERY_KEY}, ${queryFn}, ${select_option} )에서 select_option 객체에서 select프로퍼티에 데이터 정제를 지정하여 사용할 수 있다.\n   2. 장점\n      1. 데이터의 원형을 저장해놓고 필요에 따라 정제하여 쓸 수 있다\n      2. 위 3가지 중 가장 좋은 방식으로 고려된다.\n\n# # 3. 리액트 쿼리의 렌더링 최적화\n\n\u003e isFetching 전환\n\nuseQuery로 데이터를 가져올 경우 isFetching 상태가 true → false로 변환되는 과정에서 2번의 렌더링을 거치게 된다.\n\n\u003e notifyOnChangeProps: ‘data’\n\n이러한 낭비를 줄이기 위해 select option 객체에 notifyOnChangeProps 프로퍼티에 ‘data’를 값으로 주어 실제적으로 데이터가 변환되었을 경우에만 렌더링이 일어나도록 할 수 있다.\n\n\u003e 동기화유지\n\n그러나 위와같이 data값만을 트리거로 데이터의 표출을 하게 될 경우 해당 fetching이 error일 경우에 대한 표출 여부를 트리거 할 수 없다.\n\n```jsx\n// 🚨 will track all fields\nconst { isLoading, ...queryInfo } = useQuery(...)\n\n// ✅ this is totally fine\nconst { isLoading\n```\n\n```jsx\n\nconst queryInfo = useQuery(...)\n\n// 🚨 will not corectly track data\nReact.useEffect(() =\u003e {\n    console.log(queryInfo.data)\n})\n\n// ✅ fine because the dependency array is accessed during render\nReact.useEffect(() =\u003e {\n    console.log(queryInfo.data)\n}, [queryInfo.data])\n```\n\n\u003e 구조 공유\n\n```jsx\n[\n  { id: 1, name: 'Learn React', status: 'active' },\n  { id: 2, name: 'Learn React Query', status: 'todo' },\n];\n```\n\n```jsx\n[\n  -{ id: 1, name: 'Learn React', status: 'active' },\n  +{ id: 1, name: 'Learn React', status: 'done' },\n  { id: 2, name: 'Learn React Query', status: 'todo' },\n];\n```\n\n위와 같은 형식으로 todo 리스트가 있었고, 그 중에서 id가 1인 todo의 데이터가 변경되었을 경우 react-query는 나머지 데이터 ( id = 2 )의 데이터는 이전의 참조를 그대로 유지한다. 따라서 id가 2인 todo를 참조하는 ( ex : select option을 이용) component는 id가 1인 todo의 데이터가 변경되었어서 re-rendering되지 않는다.\n\n하지만 해당 query-key에 저장된 데이터가 아주 클 경우 JSON 직렬화를 통해 queryFn으로 변형된 데이터가 이전의 데이터와 변경사항이 있는지 파악해야 하기 때문에 병목현상이 생길 수 있다.\n\n따라서 이러한 최적화가 필요하지 않다면 ( 받아온 데이터가 실제로 변경된 부분만 교체하도록 하여 변경되지 않은 데이터를 참조하고 있는 component들의 re-rendering을 방지하는 최적화 ) structureSharing: false를 통해 끌 수 있다.\n\n# #4. React-query 상태 확인\n\n리액트 쿼리는 쿼리의 상태 필드에 쉽게 access 할 수 있도록 해준다. 따라서 현재 실행중인 query가 어떤 상태인지( 로딩, 에러, 패칭 등 ) 쉽게 파악이 된다. react-query에서 노출해주는 플래그값는 다음과 같다.\n\n- success: 쿼리가 성공했으며, 데이터가 있음.\n- error: 쿼리가 실패 했으며, 오류가 설정되었음.\n- loading: 쿼리를 처음으로 로드중이며, 현재 데이터가 없음.\n- idle: 쿼리 비활성 상태 ( 로드 된 적 없음 )\n\n```jsx\nconst todos = useTodos();\n\nif (todos.isLoading) {\n  return 'Loading...';\n}\nif (todos.error) {\n  return 'An error has occurred: ' + todos.error.message;\n}\n\nreturn \u003cdiv\u003e{todos.data.map(renderTodo)}\u003c/div\u003e;\n```\n\n리액트 쿼리에선 re-fetching 메커니즘이 없지만, 리액트 쿼리에선 refetchOnMount, refetchOnWindowFocus, refetchOnReconnet의 개념을 제공하여 데이터 refetch를 백그라운드에서 실행할 수 있도록해줍니다. ( 그러나 백그라운드 refetch의 실패시 혼란스러운 ux가 발생할 가능성이 있다. )\n\n\u003e 백그라운드 오류\n\n```jsx\n{\n  \"status\": \"error\",\n  \"error\": { \"message\": \"Something went wrong\" },\n  \"data\": [{ ... }]\n}\n```\n\nfetch가 실패한 쿼리의 데이터 상태는 다음과 같을 수 있다. 위와같이 fetch가 실패하였음에도, 이전에 가지고 있던 data는 삭제되지 않고 가지고 있을 수 있으며, stale-while-revalidate 캐싱 메커니즘을 수용한 결과로 볼 수 있다. (re-fetch작업은 default로 3번까지 실행된다.)\n\n# #5. React-query 테스트하기\n\n# #6. React-Query \u0026 TypeScript\n\n```jsx\nexport function useQuery\u003c\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n\u003e\n```\n\n\u003e 네가지 generic\n\n- TQueryFnData: queryFn에서 반환된 유형.\n- TError: queryFn에서 예상되는 오류 유형\n- TData: 데이터 속성. (queryFn에서 반환하는 데이터 유형과 다를 수 있음)\n- TQueryKey: queryFn에 전달된 queryKey를 사용하는 경우에만 사용하는 유형\n\n\u003e 타입 추론\n\n```jsx\nfunction identity\u003cT\u003e(value: T): T {\n  return value;\n}\n\n// 🚨 no need to provide the generic\nlet result = identity \u003c number \u003e 23;\n\n// ⚠️ or to annotate the result\nlet result: number = identity(23);\n\n// 😎 infers correctly to `string`\nlet result = identity('react-query');\n```\n\n\u003e\n\n\u003e 부분 타입 인수 추론\n\n```jsx\nfunction useGroupCount() {\n  return useQuery\u003cGroup[], Error\u003e('groups', fetchGroups, {\n    select: (groups) =\u003e groups.length,\n    // 🚨 Type '(groups: Group[]) =\u003e number' is not assignable to type '(data: Group[]) =\u003e Group[]'.\n    // Type 'number' is not assignable to type 'Group[]'.ts(2322)\n  })\n}\n```\n\n```jsx\nfunction useGroupCount() {\n  // ✅ fixed it\n  return useQuery\u003cGroup[], Error, number\u003e('groups', fetchGroups, {\n    select: (groups) =\u003e groups.length,\n  })\n}\n```\n\n위의 경우 useQuery에서 select에 대한 type을 지정해주지 않았기 때문에 타입을 추론할 수 없다.\n\n아래의 경우 number로 select부의 타입을 선언해주었기 때문에 해당 타입으로 이용이 된다.\n\n\u003e 모든것을 추론\n\n```jsx\nfunction useGroups() {\n  // 🚨 data will be `any` here\n  return useQuery('groups', () =\u003e\n    axios.get('groups').then((response) =\u003e response.data)\n  );\n}\n```\n\n만약 위와같이 axios의 반환값을 그대로 useQuery에서 이용하게 된다면, 타입을 추론할 수 없고 fetch library에서 제공하는 타입을 그대로 인용하게 된다. 따라서 타입을 유추할 수 있도록 중간 layer function을 작성하여 이용하는 방법을 쓰는게 좋다.\n\n```jsx\nfunction fetchGroups(): Promise\u003cGroup[]\u003e {\n  return axios.get('groups').then((response) =\u003e response.data);\n}\n\n// ✅ data will be `Group[] | undefined` here\nfunction useGroups() {\n  return useQuery('groups', fetchGroups);\n}\n\n// ✅ data will be `number | undefined` here\nfunction useGroupCount() {\n  return useQuery('groups', fetchGroups, {\n    select: (groups) =\u003e groups.length,\n  });\n}\n```\n\n\u003e 타입 축소\n\n```jsx\nconst { data, isSuccess } = useGroups();\nif (isSuccess) {\n  // 🚨 data will still be `Group[] | undefined` here\n}\n\nconst groupsQuery = useGroups();\nif (groupsQuery.isSuccess) {\n  // ✅ groupsQuery.data will now be `Group[]`\n}\n```\n\n위의 방식처럼 destructuring을 사용하게 되면 type추론에서 undefined가 추가될 수 있다. 따라서 구조분해할당보단 객체를 그대로 가져와서 chaning을 이용하여 이용하는것이 타입의 범위를 축소할 수 있는 좋은 방법이다.\n\n# #8. 효과적인 React-Query key\n\n리액트쿼리에서 키는 중요 핵심개념으로, 라이브러리 내부적으로 데이터를 캐시하고, re-fetch를 하기 위해 필요한 개념이다.\n\n\u003e 데이터 캐싱\n\n쿼리 캐시는 직렬화된 쿼리키를 키로 하고, 데이터와 매터정보를 갖는 javascript object를 value로 갖도록 한다.\n\n이때, query key는 고유해야 하고, useQuery ↔ useInfiniteQuery에 동일한 쿼리키를 사용할 수 없다.\n\n```jsx\nuseQuery(['todos'], fetchTodos);\n\n// 🚨 this won't work\nuseInfiniteQuery(['todos'], fetchInfiniteTodos);\n\n// ✅ choose something else instead\nuseInfiniteQuery(['infiniteTodos'], fetchInfiniteTodos);\n```\n\n\u003e 자동 다시 가져오기\n\n```jsx\nfunction Component() {\n  const { data, refetch } = useQuery(['todos'], fetchTodos)\n\n  // ❓ how do I pass parameters to refetch ❓\n  return \u003cFilters onApply={() =\u003e refetch(???)} /\u003e\n}\n```\n\n위의 코드를 보면 finter에서 필터가 select되어 apply되는 시점에 todos를 해당 필터에 맞는 것들만 필터링하여 가져오길 원한다.\n\n그러나 apply에 refetch를 하도록 하는 방식은 적절하지 않다. todos에 해당하는 cache값은 이전과 언제나 동일하게 있을테니깐. (query key값은 그대로이므로)\n\n따라서 아래와 같이 변경해야 한다.\n\n```jsx\nfunction Component() {\n  const [filters, setFilters] = React.useState();\n  const { data } = useQuery(['todos', filters], () =\u003e fetchTodos(filters));\n\n  // ✅ set local state and let it \"drive\" the query\n  return \u003cFilters onApply={setFilters} /\u003e;\n}\n```\n\n\u003e 수동 상호 작용\n\n쿼리캐시에 대한 수동적인 상호작용을 이용하기 위해선 invalidateQueries, setQueriesData를 활용할 수 있다. 이때, query filter를 지원하기 때문에 filter 객체에 명시한 조건에 해당하는 쿼리들에 관하여 상호작용하도록 컨트롤 할 수 있다.\n\n\u003e 효과적인 쿼리 키\n\n- 도메인 별로 queries.ts로 파일 관리하도록 한다.\n- 쿼리키는 항상 배열로 만든다\n- 쿼리키 배열은 일반적인것 → 구체적인것 순서로 구체화하여 구조화 한다.\n- ## 쿼리 키 팩토리 사용\n  ```jsx\n  const todoKeys = {\n    all: ['todos'] as const,\n    lists: () =\u003e [...todoKeys.all, 'list'] as const,\n    list: (filters: string) =\u003e [...todoKeys.lists(), { filters }] as const,\n    details: () =\u003e [...todoKeys.all, 'detail'] as const,\n    detail: (id: number) =\u003e [...todoKeys.details(), id] as const,\n  }\n  ```\n\n\u003e QueryFunctionContext\n\n위의 todoKeys를 보면 쿼리키를 배열로 작성했다. 이때 QueryFunctionContext를 이용하면 입력된 queryKey를 구조분해 할당시\n\n```jsx\nconst todoKeys = {\n  all: ['todos'] as const,\n  lists: () =\u003e [...todoKeys.all, 'list'] as const,\n  list: (state: State, sorting: Sorting) =\u003e\n    [...todoKeys.lists(), state, sorting] as const,\n}\n\nconst fetchTodos = async ({\n  queryKey,\n}: // 🤯 only accept keys that come from the factory\nQueryFunctionContext\u003cReturnType\u003ctypeof todoKeys['list']\u003e\u003e) =\u003e {\n  const [, , state, sorting] = queryKey\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\n  return response.data\n}\n\nexport const useTodos = () =\u003e {\n  const { state, sorting } = useTodoParams()\n\n  // ✅ build the key via the factory\n  return useQuery(todoKeys.list(state, sorting), fetchTodos)\n}\n```\n\n콤마를 이용하여 불분명하게 구분해야만 한다.\n\n따라서 이러한 문제점을 해결하기 위해 쿼리키를 객체 형태로 만들어 사용하도록 하는 방법이 좋다.\n\n```jsx\nconst todoKeys = {\n  // ✅ all keys are arrays with exactly one object\n  all: [{ scope: 'todos' }] as const,\n  lists: () =\u003e [{ ...todoKeys.all[0], entity: 'list' }] as const,\n  list: (state: State, sorting: Sorting) =\u003e\n    [{ ...todoKeys.lists()[0], state, sorting }] as const,\n}\n\nconst fetchTodos = async ({\n  // ✅ extract named properties from the queryKey\n  queryKey: [{ state, sorting }],\n}: QueryFunctionContext\u003cReturnType\u003ctypeof todoKeys['list']\u003e\u003e) =\u003e {\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\n  return response.data\n}\n\nexport const useTodos = () =\u003e {\n  const { state, sorting } = useTodoParams()\n\n  return useQuery(todoKeys.list(state, sorting), fetchTodos)\n}\n```\n\n# #9. 리액트 쿼리의 placeholder 및 init data\n\n리액트 쿼리에서 동기식으로 미리 값을 채우는 방식으로 두가지를 제공한다.\n\n- placeholder\n- initial data\n\n\u003e 유사점\n\n```jsx\nfunction Component() {\n  // ✅ status will be success even if we have not yet fetched data\n  const { data, status } = useQuery(['number'], fetchNumber, {\n    placeholderData: 23,\n  });\n\n  // ✅ same goes for initialData\n  const { data, status } = useQuery(['number'], fetchNumber, {\n    initialData: () =\u003e 42,\n  });\n}\n```\n\n두가지 모두 캐시에 해당 쿼리키로 값이 저장되어있다면, 아무런 역할을 하지 못한다.\n\n\u003e 차이점\n\n- initialData: cache수준에서 작동\n  - cache에 값이 저장된다.\n  - cache항목의 생성 순간( 첫번째 observer가 mount되는 시점 )에 값이 저장된다.\n- placeholder: observer수준에서 작동\n  - cache에 저장되지 않는다.\n  - 따라서 component마다 placeholder에 대한 값이 다를 수 있다\n\n\u003e 에러 처리\n\nbackground re-fetch가 실패했을 시\n\n- initialData\n  - 캐시엔 이미 initialData가 존배하므로 다른 background 오류와 같이 처리하면 된다.\n- placeholder\n  - cache에 데이터가 적재되려고 하는 순간 오류이므로 placeholder는 사라지고 cache엔 undefined가 저장된다.\n\n# 10. 상태관리자로서 react query\n\n\u003e 비동기 상태 관리자\n\nQueryClientProvider 하위에 존재하는 모든 component에선 queryClient를 통해 표출하는 모든 데이터는 observer로서 관찰이 가능하게 되며 해당 값의 변경을 자동으로 감지하여 rendering하게 되므로, 비동기 상태로 데이터를 관리하여 표출 가능하다.\n\n\u003e 데이터 동기화 도구\n\n리액트 쿼리의 cache데이터를 구독하는 component들은 cache에 저장된 snapshot성격의 데이터를 표시만 하는것이다. 따라서 해당 데이터가 stale 한지 fresh한지 판별하여 cache에 저장된 snapshot 데이터가 back-end와 동기화되도록 설정할 수 있다.\n\n- 리액트 쿼리 이전의 데이터 동기화\n  - 가져온 후 global로 저장하고, 업데이트 하지 않는다.\n- mount시마다 가져오고 component local에 한정\n  - useEffect(()⇒{}, []) 을 통해 가져온 데이터를 component local에서 이용한다.\n\n\u003e 데이터 재검증( 서버와 동기화 ) 하는동안 stale data 표출\n\n데이터를 서버로부터 새로 가져오는 과정은 시간이 걸리고, 화면에선 항상 loading bar || spinner가 표출되어야만 한다. 이것은 사용자 관점에서 “느리다\"는 느낌을 받게 하므로, fresh 데이터가 표출되기 전에 stale데이터가 먼저 표출되는것이 나을 수 있다.\n\n\u003e smart re-fetch\n\n- refetchOnMount\n  - mount시마다 재검증한다.\n- refetchOnWindowFocus\n  - 브라우저탭에 포커스를 할 때마다 re-fetch한다. 이게 너무 많다고 느낄 수 있으나, 사용자 관점에서 다른탭에 포커싱을 했다 해당 탭으로 돌아왔을때 fresh데이터를 표출해주는것은 사용자에게 최신의 데이터를 표시하는 완벽한 방법이다.\n- refetchOnReconnect\n  - 네트워크 연결 종료 후 fresh값을 표출해주는것 또한 화면의 값이 정확한지 여부를 다시 확인할 때 좋은 지표가 될 수 있다.\n\n만약 cache데이터를 바라보는 component를 다른 component의 하위 component로 넣을 경우 refetchOnMount를 켜놓게 되면 상위 컴포넌트 렌더링마다 하위 컴포넌트의 데이터를 계속해서 re-fetch하기 때문에 refetchOnMount를 끄는게 좋을 수 있다.\n\n\u003e staleTime 사용자 지정\n\n최신값을 표출하기 위한 목적으로 중복요청을 제거하기 위해 최소 20초 정도로 설정하는게 좋은 선택일 수 있다.\n\n이러한 설정들을 잡기위해 setQueryDefaults를 이용해 queryKey들의 기본설정을 지정할 수 있다.\n","fileName":"2024-01-28","route":"2024-01-28"}},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-01-27"},"buildId":"aRl6ChvNGBBDWk_Zx37cq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>