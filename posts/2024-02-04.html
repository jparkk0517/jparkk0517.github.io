<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="github blog 구축기(1)"/><meta property="og:description" content="깃헙 블로그 제작과 프레임워크의 선택"/><meta name="next-head-count" content="6"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><link rel="preload" href="/_next/static/css/d8e8c40d3ba5a123.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/d8e8c40d3ba5a123.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7f71bf29051388fb.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-a7bdc51c2c26039c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e98ecf209ef243c3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-92483e562f8cb0f5.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/29-526565c70891255e.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-1a97b624337d0c98.js" defer="" crossorigin=""></script><script src="/_next/static/cI7wLIEU1xrBpGI1jyCoh/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/cI7wLIEU1xrBpGI1jyCoh/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar sticky top-0 z-10 bg-base-100"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div class="flex rounded-l-xl rounded-r-none border-2 border-r-0 border-base-300"><input class="input join-item input-sm h-[30px] max-w-[30vw] focus:border-none focus:outline-none" placeholder="" value=""/><span class="mr-2 cursor-pointer"><svg class="h-full w-4 text-gray-600" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M6 18L18 6M6 6l12 12"></path></svg></span></div></div><select class="join-item select select-bordered select-sm h-[34px] border-2 focus:outline-none"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm h-[34px]">조회</button></div></div></div></div></div><main class="prose h-[95vh] overflow-y-scroll p-4 align-baseline"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">github blog 구축기(1)</h1><p class="my-4">2024.02.04</p><div class="mb-4 max-w-[80vw] break-words">깃헙 블로그 제작과 프레임워크의 선택</div><div class="badge badge-outline mr-1">next.js</div><div class="badge badge-outline mr-1">github blog</div><div class="badge badge-outline mr-1">gh-pages</div><div class="badge badge-outline mr-1">mdx</div><div class="badge badge-outline mr-1">깃헙 블로그</div></div></div></div><div class="divider"></div><div class="min-h-[58vh] max-w-[100vw] bg-white px-6"><h1>왜 깃헙 블로그로 이사를 했나</h1>
<p>이전에는 notion을 썼다. 노션 자체 기능도 많고, 글 작성도 편리했지만<br> 직접 react로 블로그를 꾸미고, 기능을 추가하는것도 재밌을것 같아 이사를 결심했다.</p>
<h2>깃헙 블로그 제작을 위해 고려했던것</h2>
<ul>
<li>static site로 제작하여 별도의 서버구축이 필요없어야 한다.</li>
<li>React 문법을 활용하여 작성이 편리하고, 향후 확장에도 용이해야 한다.</li>
<li>markdown을 이용해 작성이 가능하고, 표출이 되어야 한다.</li>
</ul>
<h2>프레임워크의 선택</h2>
<p>깃험블로그를 찾아보니 next.js 와 gatsby 두가지 프레임워크를 많이 채택하는듯 했다.
사실 두가지를 보자마자 next.js로 구축하고 싶었다.
애초에 next.js는 익숙하기도 하고, 별다른 러닝커브 없이 빠르게 구축하고 싶었기 때문이다.</p>
<p>따라서 next.js로 선택!</p>
<h1>본격적 깃헙페이지 제작</h1>
<h2>github page 생성</h2>
<p>깃헙페이지는 https://{깃헙아이디}.github.io 형태로 이용 할 수 있다.<br>따라서 이 이름으로 repository를 생성한다.</p>
<p><img src="/posts/2024-02-04/240203-225036.png" alt="240203-225036"><br>( 깃헙아이디 ).github.io 로 레포지토리 생성!!</p>
<h2>next.js 생성 및 설정</h2>

    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
$ npx create-next-app@latest</code>
      </pre>
    </div>
  
    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
<span class="hljs-comment">// next.config.mjs</span>
<span class="hljs-keyword">import</span> createMDX <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@next/mdx&#x27;</span>;

<span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import(&#x27;next&#x27;).NextConfig</span>} */</span>
<span class="hljs-keyword">const</span> nextConfig = {
  <span class="hljs-comment">// static page들로만 구성하도록 하기 위해 export 설정 추가</span>
  <span class="hljs-attr">output</span>: <span class="hljs-string">&#x27;export&#x27;</span>,
  <span class="hljs-comment">// github page는 정적 페이지로 구성되기때문에 image에 대하 optimized를 꺼준다</span>
  <span class="hljs-attr">images</span>: {
    <span class="hljs-attr">unoptimized</span>: <span class="hljs-literal">false</span>,
  },
  <span class="hljs-attr">assetPrefix</span>: <span class="hljs-string">&#x27;/&#x27;</span>,
  <span class="hljs-attr">pageExtensions</span>: [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;jsx&#x27;</span>, <span class="hljs-string">&#x27;ts&#x27;</span>, <span class="hljs-string">&#x27;tsx&#x27;</span>, <span class="hljs-string">&#x27;md&#x27;</span>, <span class="hljs-string">&#x27;mdx&#x27;</span>],
};

<span class="hljs-keyword">const</span> withMDX = <span class="hljs-title function_">createMDX</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">withMDX</span>(nextConfig);</code>
      </pre>
    </div>
  <p>위와같이 설정하면 기본적으로 github page에 정적 페이지로 표출될 수 있는 기본 설정이 마무리된다.</p>
</div><div class="mt-10 flex max-w-[100vw] justify-between"><button class="btn gap-2 md:btn-md lg:gap-3  w-[48%]"><svg class="size-6 fill-current md:size-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><span class="w-[70%] overflow-hidden text-xs">ShadowDOM에 대한 이해와 활용</span></button><button class="btn gap-2 md:btn-md lg:gap-3  w-[48%]"><span class="w-[70%] overflow-hidden  text-xs">github blog 구축기(2)</span><svg class="size-6 fill-current md:size-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><footer class="footer footer-center bg-base-100 p-4 text-base-content"><aside><p>Copyright © 2024 - sun</p></aside></footer><div class="drawer absolute bottom-[5vh] left-5 z-30 w-0"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="w-50 menu min-h-full bg-base-200 p-4 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"prev":{"meta":{"title":"ShadowDOM에 대한 이해와 활용","desc":"ShadowDOM을 활용한 CSS 은닉과 그 활용","date":"2024.02.03","tags":["shadow dom","쉐도우 돔","css 은닉"]},"content":"\n# Shadow DOM이란 무엇인가?\n\n- cssom tree를 따로 가지는 html element\n- [shadowDOM mdn 설명 보러가기](https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_shadow_DOM)\n  ![240203-163855](/posts/2024-02-03/240203-163855.png)\n  그림1. shadowDOM cssom tree구조도 ( 출처: mdn)\n\n  \u003e shadow dom을 활용하면 shadow dom 내/외부의 css가 서로 간섭없이 사용이 가능하다  \n  \u003e 만약 특정 dom element가 내/외부 의 css와 연관없이 동작하도록 하고 싶다면 shadowDOM을 활용하면 된다\n\n  ```javascript\n  const openShadowRoot = (dom: HTMLElement) =\u003e {\n    if (dom?.shadowRoot) return dom.shadowRoot;\n    const shadowRoot = dom.attachSadow({\n      mode: 'open',\n    });\n    return shadowRoot;\n  };\n\n  const shadowRoot = openShadowRoot(document.querySelector('#root'));\n  console.log(shadowRoot);\n  ```\n\n  위와같이 shadow DOM으로 활용하고자 하는 dom element에 attachShadow를 해주면\n  shadow-root가 오픈된다.\n  ![240203-164510](/posts/2024-02-03/240203-164510.png)\n  ![240203-164702](/posts/2024-02-03/240203-164702.png)\n\n  \u003chr /\u003e\n\n  ## shadowDOM의 활용 ( React )\n\n  이렇게 만든 shadowDOM을 리액트 환경에서 한번 활용해보자\n\n```typescript\n// ShadowDOM.tsx\nimport { ReactNode, useRef, useState, ReactPortal, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport default function ShadowDOM({ children }: { children?: ReactNode }) {\n  const divRef = useRef\u003cHTMLDivElement\u003e(null);\n  const [portal, setPortal] = useState\u003cReactPortal | null\u003e(null);\n\n  useEffect(() =\u003e {\n    if (!divRef.current || divRef?.current?.shadowRoot) return;\n    const shadowRoot =\n      divRef?.current?.shadowRoot ??\n      divRef.current.attachShadow({ mode: 'open' });\n    const _portal = createPortal(children, shadowRoot);\n    setPortal(_portal as ReactPortal);\n  }, [children]);\n\n  return \u003cdiv ref={divRef}\u003e{portal}\u003c/div\u003e;\n}\n\n// Home.tsx\nimport ShadowDOM from '@/components/common/ShadowDOM';\n\nexport default function Home() {\n  return (\n    \u003cShadowDOM\u003e\n      \u003cstyle\u003e\n        {'div { background-color: red; width: 200px; height: 300px;}'}\n      \u003c/style\u003e\n      \u003cdiv\u003ehome\u003c/div\u003e\n    \u003c/ShadowDOM\u003e\n  );\n}\n```\n\n![240203-182312](/posts/2024-02-03/240203-182312.png)\n![240203-182137](/posts/2024-02-03/240203-182137.png)\n\n위와같이 home 컴포넌트의 background-color가 외부에 전파되지 않는것을 확인할 수 있다.\n\n\u003ciframe\n  width='300'\n  height='400'\n  src='/home'\n  frameborder='0'\n  allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\n  allowfullscreen\u003e\u003c/iframe\u003e\n예시1. shadowDOM을 통한 css 은닉 화면 (iframe)\n","fileName":"2024-02-03","route":"2024-02-03"},"post":{"meta":{"title":"github blog 구축기(1)","desc":"깃헙 블로그 제작과 프레임워크의 선택","date":"2024.02.04","tags":["next.js","github blog","gh-pages","mdx","깃헙 블로그"]},"content":"\n# 왜 깃헙 블로그로 이사를 했나\n\n이전에는 notion을 썼다. 노션 자체 기능도 많고, 글 작성도 편리했지만  \n 직접 react로 블로그를 꾸미고, 기능을 추가하는것도 재밌을것 같아 이사를 결심했다.\n\n## 깃헙 블로그 제작을 위해 고려했던것\n\n- static site로 제작하여 별도의 서버구축이 필요없어야 한다.\n- React 문법을 활용하여 작성이 편리하고, 향후 확장에도 용이해야 한다.\n- markdown을 이용해 작성이 가능하고, 표출이 되어야 한다.\n\n## 프레임워크의 선택\n\n깃험블로그를 찾아보니 next.js 와 gatsby 두가지 프레임워크를 많이 채택하는듯 했다.\n사실 두가지를 보자마자 next.js로 구축하고 싶었다.\n애초에 next.js는 익숙하기도 하고, 별다른 러닝커브 없이 빠르게 구축하고 싶었기 때문이다.\n\n따라서 next.js로 선택!\n\n# 본격적 깃헙페이지 제작\n\n## github page 생성\n\n깃헙페이지는 https://{깃헙아이디}.github.io 형태로 이용 할 수 있다.  \n따라서 이 이름으로 repository를 생성한다.\n\n![240203-225036](/posts/2024-02-04/240203-225036.png)  \n( 깃헙아이디 ).github.io 로 레포지토리 생성!!\n\n## next.js 생성 및 설정\n\n```bash\n$ npx create-next-app@latest\n```\n\n```mjs\n// next.config.mjs\nimport createMDX from '@next/mdx';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // static page들로만 구성하도록 하기 위해 export 설정 추가\n  output: 'export',\n  // github page는 정적 페이지로 구성되기때문에 image에 대하 optimized를 꺼준다\n  images: {\n    unoptimized: false,\n  },\n  assetPrefix: '/',\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n};\n\nconst withMDX = createMDX();\n\nexport default withMDX(nextConfig);\n```\n\n위와같이 설정하면 기본적으로 github page에 정적 페이지로 표출될 수 있는 기본 설정이 마무리된다.\n","fileName":"2024-02-04","route":"2024-02-04"},"next":{"meta":{"title":"github blog 구축기(2)","desc":"github page를 배포하는 과정을 알아보자","date":"2024.02.05","tags":["next.js","github blog","gh-pages","mdx"]},"content":"\n# 블로그 글 작성 및 표출하는 방법은?\n\n- 기본적으로 포스팅은 markdown으로 작성하도록 하고싶다.\n  - 작성 과정에서 markdown으로 글을 확인하고, 그대로 표출되도록 하고싶기 때문\n- 별도 서버 없이 작성한 post markdown파일을 github에 저장하고, 그걸 그대로 표출 하고싶다.\n\n=\u003e mdx 파일로 작성하고, meta 정보를 parsing하여 글 목록에 표출하도록 하고, 표스팅 내용은 dynamic routing으로 확인할 수 있는 구조로 짜도록 하자!\n\n![240205-212509](/posts/2024-02-05/240205-212509.png)\n그림1. src 폴더 하부 구조\n\n기본적인 폴더 구조는 다음과 같이\n/pages 폴더 밑에 [postId].tsx를 두어 dynamic routing이 가능하도록 했다.\n\n# 본격 github page 배포\n\n\u003e gh-pages library를 사용!\n\u003e [gh-pages npm repository](https://www.npmjs.com/package/gh-pages)\n\ngithub page에 내가 작성한 markdown을 포스팅으로 표출하기 위해\ngh-pages를 활용하도록 하고 deploy 스크립트는 다음과 같이 짰다.\n\n```bash\n # package.json\n \"deploy\": \"next build \u0026\u0026 touch out/.nojekyll \u0026\u0026 gh-pages -d out --dotfiles\",\n```\n\n이제 yarn deploy 명령어를 통해  \n 연결한 git repository의 gh-pages 브랜치에 빌드된 결과물이 올라가게 된다.  \n 이때 github repository 설정에서 표출할 branch를 gh-pages로 변경시켜준다.\n\n![240205-213613](/posts/2024-02-05/240205-213613.png)\n그림2. github repository settings\n\n![240205-213633](/posts/2024-02-05/240205-213633.png)\n그림3. gh-pages 브랜치를 github page 메인브랜치로 이용하도록 변경\n\n위와같이 설정했다면\nyarn deploy 명령어를 통해 github page가 배포됨을 알 수 있다.\n","fileName":"2024-02-05","route":"2024-02-05"}},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-02-04"},"buildId":"cI7wLIEU1xrBpGI1jyCoh","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>