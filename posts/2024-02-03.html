<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({&#x27;gtm.start&#x27;:
new Date().getTime(),event:&#x27;gtm.js&#x27;});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!=&#x27;dataLayer&#x27;?&#x27;&amp;l=&#x27;+l:&#x27;&#x27;;j.async=true;j.src=
&#x27;https://www.googletagmanager.com/gtm.js?id=&#x27;+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,&#x27;script&#x27;,&#x27;dataLayer&#x27;,&#x27;GTM-K5DKF9QN&#x27;);</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="ShadowDOM에 대한 이해와 활용"/><meta property="og:description" content="ShadowDOM을 활용한 CSS 은닉과 그 활용"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/b3f792bf4938b7bb.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/b3f792bf4938b7bb.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-4a4b57aae811a069.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-550f72cae410482c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e6e0b507836a963c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-5fdb6cf0f4b8ef0d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/281-ba438958aa97dd96.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-e3bccff15d070bf4.js" defer="" crossorigin=""></script><script src="/_next/static/n6oFI-TCo1QgyK6KDl2dc/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/n6oFI-TCo1QgyK6KDl2dc/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar bg-base-100 sticky top-0 z-10"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div class="flex border-base-300 border-2 border-r-0 rounded-l-xl rounded-r-none"><input class="input input-sm join-item max-w-[30vw] focus:outline-none focus:border-none h-[30px]" placeholder="" value=""/><span class="cursor-pointer mr-2"><svg class="w-4 text-gray-600 h-[100%]" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M6 18L18 6M6 6l12 12"></path></svg></span></div></div><select class="select select-bordered join-item select-sm h-[34px] border-2 focus:outline-none"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm h-[34px]">조회</button></div></div></div></div></div><main class="prose p-4 align-baseline overflow-y-scroll h-[95vh]"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">ShadowDOM에 대한 이해와 활용</h1><p class="my-4">2024.02.03</p><div class="max-w-[80vw] break-words mb-4">ShadowDOM을 활용한 CSS 은닉과 그 활용</div><div class="badge badge-outline mr-1">shadow dom</div><div class="badge badge-outline mr-1">쉐도우 돔</div><div class="badge badge-outline mr-1">css 은닉</div></div></div></div><div class="divider"></div><div class="markdown-body min-h-[58vh] px-6 max-w-[100vw]"><h1>Shadow DOM이란 무엇인가?</h1>
<ul>
<li><p>cssom tree를 따로 가지는 html element</p>
</li>
<li><p><a href="https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_shadow_DOM">shadowDOM mdn 설명 보러가기</a>
<img src="/posts/2024-02-03/240203-163855.png" alt="240203-163855">
그림1. shadowDOM cssom tree구조도 ( 출처: mdn)</p>
<blockquote>
<p>shadow dom을 활용하면 shadow dom 내/외부의 css가 서로 간섭없이 사용이 가능하다<br>만약 특정 dom element가 내/외부 의 css와 연관없이 동작하도록 하고 싶다면 shadowDOM을 활용하면 된다</p>
</blockquote>

    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">openShadowRoot</span> = (<span class="hljs-params">dom: HTMLElement</span>) =&gt; {
  <span class="hljs-keyword">if</span> (dom?.<span class="hljs-property">shadowRoot</span>) <span class="hljs-keyword">return</span> dom.<span class="hljs-property">shadowRoot</span>;
  <span class="hljs-keyword">const</span> shadowRoot = dom.<span class="hljs-title function_">attachSadow</span>({
    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span>,
  });
  <span class="hljs-keyword">return</span> shadowRoot;
};

<span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-title function_">openShadowRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#root&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shadowRoot);</code>
      </pre>
    </div>
  <p>위와같이 shadow DOM으로 활용하고자 하는 dom element에 attachShadow를 해주면
shadow-root가 오픈된다.
<img src="/posts/2024-02-03/240203-164510.png" alt="240203-164510">
<img src="/posts/2024-02-03/240203-164702.png" alt="240203-164702"></p>
<hr />

<h2>shadowDOM의 활용 ( React )</h2>
<p>이렇게 만든 shadowDOM을 리액트 환경에서 한번 활용해보자</p>
</li>
</ul>

    <div class="mockup-code text-black border bg-[#f6f8fa]" style="width:90%;margin:auto;margin-bottom:20px;">
      <pre style="margin-bottom:0;padding:0;">
      <code>
<span class="hljs-comment">// ShadowDOM.tsx</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ReactNode</span>, useRef, useState, <span class="hljs-title class_">ReactPortal</span>, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { createPortal } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ShadowDOM</span>(<span class="hljs-params">{ children }: { children?: ReactNode }</span>) {
  <span class="hljs-keyword">const</span> divRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [portal, setPortal] = useState&lt;<span class="hljs-title class_">ReactPortal</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!divRef.<span class="hljs-property">current</span> || divRef?.<span class="hljs-property">current</span>?.<span class="hljs-property">shadowRoot</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> shadowRoot =
      divRef?.<span class="hljs-property">current</span>?.<span class="hljs-property">shadowRoot</span> ??
      divRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span> });
    <span class="hljs-keyword">const</span> _portal = <span class="hljs-title function_">createPortal</span>(children, shadowRoot);
    <span class="hljs-title function_">setPortal</span>(_portal <span class="hljs-keyword">as</span> <span class="hljs-title class_">ReactPortal</span>);
  }, [children]);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{divRef}</span>&gt;</span>{portal}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-comment">// Home.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ShadowDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/common/ShadowDOM&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ShadowDOM</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
        {&#x27;div { background-color: red; width: 200px; height: 300px;}&#x27;}
      <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ShadowDOM</span>&gt;</span></span>
  );
}</code>
      </pre>
    </div>
  <p><img src="/posts/2024-02-03/240203-182312.png" alt="240203-182312">
<img src="/posts/2024-02-03/240203-182137.png" alt="240203-182137"></p>
<p>위와같이 home 컴포넌트의 background-color가 외부에 전파되지 않는것을 확인할 수 있다.</p>
<iframe
  width='300'
  height='400'
  src='/home'
  frameborder='0'
  allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'
  allowfullscreen></iframe>
예시1. shadowDOM을 통한 css 은닉 화면 (iframe)
</div><div class="flex justify-between mt-10 max-w-[100vw]"><button class="btn btn-8xl md:btn-md gap-2 lg:gap-3  w-[48%]"><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><span class="w-[70%] overflow-hidden text-xs">브라우저의 렌더링</span></button><button class="btn btn-8xl md:btn-md gap-2 lg:gap-3  w-[48%]"><span class="w-[70%] overflow-hidden  text-xs">github blog 구축기(1)</span><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><footer class="footer footer-center p-4 bg-base-100 text-base-content"><aside><p>Copyright © 2024 - sun</p></aside></footer><div class="drawer absolute left-5 z-30 w-0 bottom-[5vh]"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="menu p-4 w-50 min-h-full bg-base-200 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"prev":{"meta":{"title":"브라우저의 렌더링","desc":"브라우저의 렌더링 순서","date":"2024.02.02","tags":["브라우저","렌더링","CSSOM","AST"]},"content":"\n# 브라우저의 렌더링 순서\n\n1. HTML, CSS, Javascript, static files 등의 리소스를 요청 하고 응답 받는다.\n2. HTML, CSS를 파싱하여 DOM, CSSOM을 생성하여 렌더트리를 생성한다.\n   1. DOM 파싱\n      1. 서버에서 HTML을 바이트(2진수)형태로 응답받는다.\n      2. meta tag의 charset 어트리뷰트를 통해 인코딩 방식을 인식하고 해당 인코딩 방식으로 문자열 치환한다.\n      3. 해당 문자열을 문법적 최소 의미 단위를 갖는 토큰으로 분해한다.\n      4. 분해된 토큰을 기반으로 노드 객체를 생성한다.\n      5. 생성된 노드들은 트리구조로 되어있으며 이러한 구조를 DOM(Document Obejct Model)이라고 부른다.\n   2. CSSOM 파싱\n      1. DOM 생성( HTML 파싱 )중 link tag를 만나면 DOM 파싱을 중단한다.\n      2. link태그에 지정된 href 로 요청을 보내 css 파일을 다운로드 한다.\n      3. 다운받은 css파일을 DOM파싱과 동일한 과정을 거쳐 tree 구조의 객체들로 만들고 그것을 CSSOM(CSS Object Model)이라고 부른다.\n   3. 렌더트리\n      1. DOM과 CSSOM을 렌더트리로 결합한다.\n      2. 화면에 렌더링 되지 않는 태그( = script, link 및 css에 의해 비표출 되는 노드들)은 제외된다.\n      3. 생성된 렌더트리는 요소들의 레이아웃 계산에 사용되며 이를 통해 페인팅을 실행한다.\n3. 자바스크립트를 파싱하여 AST(Absctract Syntax Tree)를 생성하고, 바이트 코드로 변환하여 실행한다.\n   1. 자바스크립트의 파싱\n      1. DOM 생성 과정에서 script태그를 만나면 DOM 파싱을 중단하고 js를 파싱한다.\n      2. 파싱은 자바스크립트 엔진(V8, spiderMonkey, javaScriptCore 등)에서 일어난다.\n      3. 제어권을 넘겨받은 자바스크립트 엔진은 AST(Abstract Syntax Tree)를 생성한다.\n   2. 자바스크립트 소스 파싱의 순서\n      1. 토크나이징 : 토크나이저가 자바스크립트 소스를 토큰 단위로 분해한다.\n      2. 파싱 : 토큰들을 분석하여 AST를 생헌한다.\n      3. 바이트코드 생성 : AST를 인터프리터가 실행할 수 있는 바이트 코드로 변환 한다.\n         1. V8의 경우 자주 실행되는 코드는 터보팬(컴파일러)에 의해 Optimized Machine Code로 컴파일 되어 성능 최적화를 진행하며, 사용 빈도가 적어지만 Deoptimizing한다.\n      4. 실행 : 인터프리터가 바이트코드를 읽어 로직을 실행한다.\n4. 렌더트리를 기반으로 HTML요소의 레이아웃을 계산하고 브라우저 화면에 페인팅한다.\n\n### Reference\n\n- 자바스크립트 딥 다이브 (38장)\n","fileName":"2024-02-02","route":"2024-02-02"},"post":{"meta":{"title":"ShadowDOM에 대한 이해와 활용","desc":"ShadowDOM을 활용한 CSS 은닉과 그 활용","date":"2024.02.03","tags":["shadow dom","쉐도우 돔","css 은닉"]},"content":"\n# Shadow DOM이란 무엇인가?\n\n- cssom tree를 따로 가지는 html element\n- [shadowDOM mdn 설명 보러가기](https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_shadow_DOM)\n  ![240203-163855](/posts/2024-02-03/240203-163855.png)\n  그림1. shadowDOM cssom tree구조도 ( 출처: mdn)\n\n  \u003e shadow dom을 활용하면 shadow dom 내/외부의 css가 서로 간섭없이 사용이 가능하다  \n  \u003e 만약 특정 dom element가 내/외부 의 css와 연관없이 동작하도록 하고 싶다면 shadowDOM을 활용하면 된다\n\n  ```javascript\n  const openShadowRoot = (dom: HTMLElement) =\u003e {\n    if (dom?.shadowRoot) return dom.shadowRoot;\n    const shadowRoot = dom.attachSadow({\n      mode: 'open',\n    });\n    return shadowRoot;\n  };\n\n  const shadowRoot = openShadowRoot(document.querySelector('#root'));\n  console.log(shadowRoot);\n  ```\n\n  위와같이 shadow DOM으로 활용하고자 하는 dom element에 attachShadow를 해주면\n  shadow-root가 오픈된다.\n  ![240203-164510](/posts/2024-02-03/240203-164510.png)\n  ![240203-164702](/posts/2024-02-03/240203-164702.png)\n\n  \u003chr /\u003e\n\n  ## shadowDOM의 활용 ( React )\n\n  이렇게 만든 shadowDOM을 리액트 환경에서 한번 활용해보자\n\n```typescript\n// ShadowDOM.tsx\nimport { ReactNode, useRef, useState, ReactPortal, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport default function ShadowDOM({ children }: { children?: ReactNode }) {\n  const divRef = useRef\u003cHTMLDivElement\u003e(null);\n  const [portal, setPortal] = useState\u003cReactPortal | null\u003e(null);\n\n  useEffect(() =\u003e {\n    if (!divRef.current || divRef?.current?.shadowRoot) return;\n    const shadowRoot =\n      divRef?.current?.shadowRoot ??\n      divRef.current.attachShadow({ mode: 'open' });\n    const _portal = createPortal(children, shadowRoot);\n    setPortal(_portal as ReactPortal);\n  }, [children]);\n\n  return \u003cdiv ref={divRef}\u003e{portal}\u003c/div\u003e;\n}\n\n// Home.tsx\nimport ShadowDOM from '@/components/common/ShadowDOM';\n\nexport default function Home() {\n  return (\n    \u003cShadowDOM\u003e\n      \u003cstyle\u003e\n        {'div { background-color: red; width: 200px; height: 300px;}'}\n      \u003c/style\u003e\n      \u003cdiv\u003ehome\u003c/div\u003e\n    \u003c/ShadowDOM\u003e\n  );\n}\n```\n\n![240203-182312](/posts/2024-02-03/240203-182312.png)\n![240203-182137](/posts/2024-02-03/240203-182137.png)\n\n위와같이 home 컴포넌트의 background-color가 외부에 전파되지 않는것을 확인할 수 있다.\n\n\u003ciframe\n  width='300'\n  height='400'\n  src='/home'\n  frameborder='0'\n  allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\n  allowfullscreen\u003e\u003c/iframe\u003e\n예시1. shadowDOM을 통한 css 은닉 화면 (iframe)\n","fileName":"2024-02-03","route":"2024-02-03"},"next":{"meta":{"title":"github blog 구축기(1)","desc":"깃헙 블로그 제작과 프레임워크의 선택","date":"2024.02.04","tags":["next.js","github blog","gh-pages","mdx","깃헙 블로그"]},"content":"\n# 왜 깃헙 블로그로 이사를 했나\n\n이전에는 notion을 썼다. 노션 자체 기능도 많고, 글 작성도 편리했지만  \n 직접 react로 블로그를 꾸미고, 기능을 추가하는것도 재밌을것 같아 이사를 결심했다.\n\n## 깃헙 블로그 제작을 위해 고려했던것\n\n- static site로 제작하여 별도의 서버구축이 필요없어야 한다.\n- React 문법을 활용하여 작성이 편리하고, 향후 확장에도 용이해야 한다.\n- markdown을 이용해 작성이 가능하고, 표출이 되어야 한다.\n\n## 프레임워크의 선택\n\n깃험블로그를 찾아보니 next.js 와 gatsby 두가지 프레임워크를 많이 채택하는듯 했다.\n사실 두가지를 보자마자 next.js로 구축하고 싶었다.\n애초에 next.js는 익숙하기도 하고, 별다른 러닝커브 없이 빠르게 구축하고 싶었기 때문이다.\n\n따라서 next.js로 선택!\n\n# 본격적 깃헙페이지 제작\n\n## github page 생성\n\n깃헙페이지는 https://{깃헙아이디}.github.io 형태로 이용 할 수 있다.  \n따라서 이 이름으로 repository를 생성한다.\n\n![240203-225036](/posts/2024-02-04/240203-225036.png)  \n( 깃헙아이디 ).github.io 로 레포지토리 생성!!\n\n## next.js 생성 및 설정\n\n```bash\n$ npx create-next-app@latest\n```\n\n```mjs\n// next.config.mjs\nimport createMDX from '@next/mdx';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // static page들로만 구성하도록 하기 위해 export 설정 추가\n  output: 'export',\n  // github page는 정적 페이지로 구성되기때문에 image에 대하 optimized를 꺼준다\n  images: {\n    unoptimized: false,\n  },\n  assetPrefix: '/',\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n};\n\nconst withMDX = createMDX();\n\nexport default withMDX(nextConfig);\n```\n\n위와같이 설정하면 기본적으로 github page에 정적 페이지로 표출될 수 있는 기본 설정이 마무리된다.\n","fileName":"2024-02-04","route":"2024-02-04"}},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-02-03"},"buildId":"n6oFI-TCo1QgyK6KDl2dc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>