<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({&#x27;gtm.start&#x27;:
new Date().getTime(),event:&#x27;gtm.js&#x27;});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!=&#x27;dataLayer&#x27;?&#x27;&amp;l=&#x27;+l:&#x27;&#x27;;j.async=true;j.src=
&#x27;https://www.googletagmanager.com/gtm.js?id=&#x27;+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,&#x27;script&#x27;,&#x27;dataLayer&#x27;,&#x27;GTM-K5DKF9QN&#x27;);</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jparkk0517.github.io"/><meta property="og:title" content="Rail 모델"/><meta property="og:description" content="브라우저 사용자 경험에 대한 지표 Rail모델"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/ab0e1143a74b7294.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/ab0e1143a74b7294.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5c3da54741072322.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5c3da54741072322.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-6c19d7d3ff020263.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-289999ca7976cd50.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-2e87bac3729cf9f3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-54b1da1d03952d5a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/346-c3d964f55d703767.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5BpostId%5D-c66e23fe350e6961.js" defer="" crossorigin=""></script><script src="/_next/static/Pq3gfwJpm76rkBK6R679W/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/Pq3gfwJpm76rkBK6R679W/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar bg-base-100 sticky top-0 z-10"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div><input class="input input-sm input-bordered join-item max-w-[30vw]" placeholder="" value=""/></div></div><select class="select select-bordered join-item select-sm"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm">조회</button></div></div></div></div></div><main class="prose p-4 align-baseline overflow-y-scroll h-[85vh]"><div class="mb-20"><div class="hero bg-base-300"><div class="hero-content text-center"><div class="max-w-md"><h1 class="text-5xl font-bold">Rail 모델</h1><p class="my-4">2024.02.01</p><div class="max-w-[80vw] break-words mb-4">브라우저 사용자 경험에 대한 지표 Rail모델</div><div class="badge badge-outline ">Rail</div><div class="badge badge-outline ">브라우저</div><div class="badge badge-outline ">렌더링</div><div class="badge badge-outline ">사용자 경험</div></div></div></div><div class="divider"></div><article class="markdown-body min-h-[58vh] px-6"><div><h1>Rail 모델</h1>
<ul>
<li>Rail은 브라우저에서의 성능에 대해 생각할 수 있도록 해주는 사용주 중심 성능 모델</li>
<li>4가지 웹앱의 생명주기를 통해 성능 지표를 나타냄(response, animation, idle, load)</li>
<li>구체적 목표와 지침을 지정하여 성능 측정 항목으로 이용할 수 있도록 함</li>
</ul>
<p><img src="/posts/2024-02-01/240203-210333.png" alt="240203-210333"></p>
<p>출처: <a href="https://web.dev/rail/#response-process-events-in-under-50ms">https://web.dev/rail/#response-process-events-in-under-50ms</a></p>
<h1>Rail모델에서 바라본 사용자 경험에 대한 기준</h1>
<p>| 0~16ms | - 사용자는 초당 60개의 프레임이 렌더링되는걸 부드럽다고 인식한다</p>
<ul>
<li>브라우저에서 새 프레임을 그리는데는 16ms가 걸린다.</li>
<li>| 사용자가 애니메이션이 매우 매끄럽다고 느낌 |
| ------------------------------------------ | ---------------------------------------------- |
| 0~100ms                                    | - 이 정도 응답에선 즉각적 반응이 일어난다 느낌 |</li>
<li>하지만 더 길어지면 동작 ↔ 응답 이 끊어진다는 느낌을 받음 |
| 100~1,000ms | - 자연스럽고 지속적 작업의 일부로 받아들일 수 있는 수준</li>
<li>대부분의 웹앱의 상태 |
| 1,000ms ~ 10,000ms | - 1초를 초과하므라 사용자는 작업에 집중을 잃게됨 |
| 10,000ms 이상 | - 사용자 이탈 |</li>
</ul>
<h1>Response: 50ms 미만의 이벤트 처리 목표</h1>
<ul>
<li>목표 : 사용자 입력에 대한 interaction이 100ms이내에 완료되어 전달 될 수 있도록(즉각적이다는 느낌)</li>
<li>지침<ul>
<li>터치, 스크롤등 연결되는 동작은 제외하고, 클릭, 토글등의 이벤트에 적용</li>
<li>리소스가 많이 필요한 작업이라면 백그라운드로 동작할 수 있도록(사용자 경험을 차단하지 않도록)</li>
<li>50ms를 넘기는 응답에 대해선 피드백을 제공할 수 있도록한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>100ms 응답을 위해선 고작 50ms의 여유만 존재한다.</p>
</blockquote>
<p>목표가 100ms인 응답을 주려고 할 때, 개발자에게 가용한 시간은 50ms에 불과하다.</p>
<p>목표하는 task처리외에도 입력에 대한 입력을 수용하고, 응답을 표출하기위한 처리시간 또한 필요하므로 실제 사용할 수 있는 시간은 50ms정도!</p>
<p><img src="/posts/2024-02-01/240203-210345.png" alt="240203-210345"></p>
<p>출처 : <a href="https://web.dev/rail/#response-process-events-in-under-50ms">https://web.dev/rail/#response-process-events-in-under-50ms</a></p>
<h1>Animation : 10ms안에 프레임 생성</h1>
<ul>
<li>목표<ul>
<li>애니메이션을 각 10ms 프레임 이하로 생성</li>
<li>각 프레임의 최대예산은 16ms지만 브라우저가 프레임을 렌더링하는 시간이 필요하므로 10ms만 가용</li>
<li>시각적 부드러움이 목표!</li>
</ul>
</li>
<li>지침<ul>
<li>애니메이션 처리와 같이 높은 연산이 필요한 작업에는 다른 작업을 포함하지 않는다.</li>
<li>스크롤, 로드표시 와 같은 시각적 애니메이션등을 포함하는 개념들에 적용</li>
<li>렌더링 성능의 원리는 적극 참조한다.</li>
</ul>
</li>
</ul>
<h1>Idle: 유휴시간 극대화</h1>
<ul>
<li>목표<ul>
<li>idle time을 최대화하여 사용자의 입력에 50ms이내 응답할 수 있도록 한다.</li>
</ul>
</li>
<li>지침<ul>
<li>초기 페이지 로드를 가볍게 하고, 유휴 시간에 나머지를 로드하도록 한다.</li>
<li>50ms를 넘는 작업은 다른 사용자 입력에 대한 응답에 방해가 될 수 있으므로, 그 이내 시간에 할 수 있도록 한다.</li>
<li>유휴 작업중 사용자 입력이 있다면, 우선순위에 따라 작동하도록 한다.</li>
</ul>
</li>
</ul>
<h1>Load : 최대 5초 이내 콘텐츠 전달 후 상호작용 준비</h1>
<ul>
<li>목표<ul>
<li>slow 3g상황에서도 5초 이내에 콘텐츠를 전달하고 상호작용에 준비할 수 있도록 한다.</li>
</ul>
</li>
<li><h2>지침</h2>
</li>
</ul>
<h1>Rail 측정도구</h1>
<ul>
<li>chrome devtools</li>
<li>Lighthouse</li>
<li>WebPageTest</li>
</ul>
<h1>Referrence</h1>
</div></article><div class="flex justify-between"><button class="btn btn-neutral btn-sm md:btn-md gap-2 lg:gap-3 "><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"></path></svg><div class="flex flex-col items-start"><span class="text-base-content/50 hidden text-xs font-normal md:block">Prev</span><span>DOM</span></div></button><button class="btn btn-neutral btn-sm md:btn-md gap-2 lg:gap-3 "><div class="flex flex-col items-end"><span class="text-neutral-content/50 hidden text-xs font-normal md:block">Next</span><span>브라우저의 렌더링</span></div><svg class="h-6 w-6 fill-current md:h-8 md:w-8" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"></path></svg></button></div></div><div class="drawer absolute left-5 z-30 w-0 bottom-[10vh]"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="menu p-4 w-50 min-h-full bg-base-200 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main><footer class="footer footer-center p-4 bg-base-100 text-base-content w-screen"><aside><p>Copyright © 2024 - sun</p></aside></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"meta":{"title":"Rail 모델","desc":"브라우저 사용자 경험에 대한 지표 Rail모델","date":"2024.02.01","tags":["Rail","브라우저","렌더링","사용자 경험"]},"content":"\n# Rail 모델\n\n- Rail은 브라우저에서의 성능에 대해 생각할 수 있도록 해주는 사용주 중심 성능 모델\n- 4가지 웹앱의 생명주기를 통해 성능 지표를 나타냄(response, animation, idle, load)\n- 구체적 목표와 지침을 지정하여 성능 측정 항목으로 이용할 수 있도록 함\n\n![240203-210333](/posts/2024-02-01/240203-210333.png)\n\n출처: https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Rail모델에서 바라본 사용자 경험에 대한 기준\n\n| 0~16ms | - 사용자는 초당 60개의 프레임이 렌더링되는걸 부드럽다고 인식한다\n\n- 브라우저에서 새 프레임을 그리는데는 16ms가 걸린다.\n- | 사용자가 애니메이션이 매우 매끄럽다고 느낌 |\n  | ------------------------------------------ | ---------------------------------------------- |\n  | 0~100ms                                    | - 이 정도 응답에선 즉각적 반응이 일어난다 느낌 |\n- 하지만 더 길어지면 동작 ↔ 응답 이 끊어진다는 느낌을 받음 |\n  | 100~1,000ms | - 자연스럽고 지속적 작업의 일부로 받아들일 수 있는 수준\n- 대부분의 웹앱의 상태 |\n  | 1,000ms ~ 10,000ms | - 1초를 초과하므라 사용자는 작업에 집중을 잃게됨 |\n  | 10,000ms 이상 | - 사용자 이탈 |\n\n# Response: 50ms 미만의 이벤트 처리 목표\n\n- 목표 : 사용자 입력에 대한 interaction이 100ms이내에 완료되어 전달 될 수 있도록(즉각적이다는 느낌)\n- 지침\n  - 터치, 스크롤등 연결되는 동작은 제외하고, 클릭, 토글등의 이벤트에 적용\n  - 리소스가 많이 필요한 작업이라면 백그라운드로 동작할 수 있도록(사용자 경험을 차단하지 않도록)\n  - 50ms를 넘기는 응답에 대해선 피드백을 제공할 수 있도록한다.\n\n\u003e 100ms 응답을 위해선 고작 50ms의 여유만 존재한다.\n\n목표가 100ms인 응답을 주려고 할 때, 개발자에게 가용한 시간은 50ms에 불과하다.\n\n목표하는 task처리외에도 입력에 대한 입력을 수용하고, 응답을 표출하기위한 처리시간 또한 필요하므로 실제 사용할 수 있는 시간은 50ms정도!\n\n![240203-210345](/posts/2024-02-01/240203-210345.png)\n\n출처 : https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Animation : 10ms안에 프레임 생성\n\n- 목표\n  - 애니메이션을 각 10ms 프레임 이하로 생성\n  - 각 프레임의 최대예산은 16ms지만 브라우저가 프레임을 렌더링하는 시간이 필요하므로 10ms만 가용\n  - 시각적 부드러움이 목표!\n- 지침\n  - 애니메이션 처리와 같이 높은 연산이 필요한 작업에는 다른 작업을 포함하지 않는다.\n  - 스크롤, 로드표시 와 같은 시각적 애니메이션등을 포함하는 개념들에 적용\n  - 렌더링 성능의 원리는 적극 참조한다.\n\n# Idle: 유휴시간 극대화\n\n- 목표\n  - idle time을 최대화하여 사용자의 입력에 50ms이내 응답할 수 있도록 한다.\n- 지침\n  - 초기 페이지 로드를 가볍게 하고, 유휴 시간에 나머지를 로드하도록 한다.\n  - 50ms를 넘는 작업은 다른 사용자 입력에 대한 응답에 방해가 될 수 있으므로, 그 이내 시간에 할 수 있도록 한다.\n  - 유휴 작업중 사용자 입력이 있다면, 우선순위에 따라 작동하도록 한다.\n\n# Load : 최대 5초 이내 콘텐츠 전달 후 상호작용 준비\n\n- 목표\n  - slow 3g상황에서도 5초 이내에 콘텐츠를 전달하고 상호작용에 준비할 수 있도록 한다.\n- ## 지침\n\n# Rail 측정도구\n\n- chrome devtools\n- Lighthouse\n- WebPageTest\n\n# Referrence\n","fileName":"2024-02-01","route":"2024-02-01"},"prev":{"meta":{"title":"DOM","desc":"Document Object Model에 대한 공부","date":"2024.01.31","tags":["DOM","Document Object Model"]},"content":"\n# 노드\n\n\u003e HTML요소와 노드 객체\n\n- HTML요소 : HTML문서를 구성하는 개별 요소\n  - HTML요소의 구조\n    - 시작태그(start tag)\n    - 어트리뷰트 명 (attribute name)\n    - 어트리뷰트 값 (attribute value)\n    - 콘텐츠 (contents)\n- HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.\n\n\u003e 노드 타입의 종류\n\n- 문서 노드( document node )\n  - DOM트리 최상에 존재하는 루트 노드\n  - document 객체를 가리킨다.\n- 요소 노드 (element node)\n  - HTML요소를 가리키는 객체\n- 어트리뷰트 노드 (attribute node)\n  - HTML요소의 attribute를 가리키는 객체\n  - HTML 요소 노드의 sibling관계를 갖는다.\n  - 부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.\n- 텍스트 노드 (text node)\n  - element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드\n\n\u003e 노드 객체의 상속구조\n\n노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.\n\n노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.\n\n![240203-210458](/posts/2024-01-31/240203-210458.png)\n\n그림. 노드객체의 상속구조(구글 검색)\n\n위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.\n\n이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.\n\n```jsx\nconst input = document.createElement('input');\n/*\n\t최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위\n*/\n```\n\n\u003e Element node의 텍스트 조작\n\n1. nodeValue\n\n   1. nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.\n\n   ```jsx\n   \u003cdiv id='text'\u003ehello\u003c/div\u003e;\n   const hello = document.querySelector('#text');\n   console.log(hello.nodeValue); // null\n   console.log(hello.firstChild.nodeValue); // hello\n   ```\n\n2. textContent\n\n   1. getter와 setter가 모두 존재하는 접근자 프로퍼티.\n   2. textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)\n   3. ```jsx\n      \u003cdiv id='text'\u003e\n        hello \u003cspan\u003eworld\u003c/span\u003e\n      \u003c/div\u003e;\n      const hello = document.querySelector('#text');\n      console.log(hello.textContent); // hello world\n      ```\n\n   4. element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.\n   5. innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.\n      1. innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.\n      2. css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.\n\n   \u003e 어트리뷰트\n\n   HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.\n\n   - HTML어트리뷰트 vs DOM프로퍼티\n     - 어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.\n     - 따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.\n     - ![240203-210509](/posts/2024-01-31/240203-210509.png)\n     - DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!\n   - HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계\n     - id attribute 와 id property 는 1대1대응\n     - value attribute ⇒ 초깃값, value property ⇒ 최신값\n     - class attribute ⇒ className, classList와 대응\n     - for attribute ⇒ htmlFor 프로퍼티와 1대1 대응\n     - td요소의 colspan attribute는 대응하는 프로퍼티 없음\n     - textContent 프로퍼티는 대응하는 어트리뷰트 없음\n     - attribute는 대소문자x, property는 카멜케이스\n     -\n\n# 레퍼런스\n\n1. 모던 자바스크립트 deep dive(p.677)\n","fileName":"2024-01-31","route":"2024-01-31"},"next":{"meta":{"title":"브라우저의 렌더링","desc":"브라우저의 렌더링 순서","date":"2024.02.02","tags":["브라우저","렌더링","CSSOM","AST"]},"content":"\n# 브라우저의 렌더링 순서\n\n1. HTML, CSS, Javascript, static files 등의 리소스를 요청 하고 응답 받는다.\n2. HTML, CSS를 파싱하여 DOM, CSSOM을 생성하여 렌더트리를 생성한다.\n   1. DOM 파싱\n      1. 서버에서 HTML을 바이트(2진수)형태로 응답받는다.\n      2. meta tag의 charset 어트리뷰트를 통해 인코딩 방식을 인식하고 해당 인코딩 방식으로 문자열 치환한다.\n      3. 해당 문자열을 문법적 최소 의미 단위를 갖는 토큰으로 분해한다.\n      4. 분해된 토큰을 기반으로 노드 객체를 생성한다.\n      5. 생성된 노드들은 트리구조로 되어있으며 이러한 구조를 DOM(Document Obejct Model)이라고 부른다.\n   2. CSSOM 파싱\n      1. DOM 생성( HTML 파싱 )중 link tag를 만나면 DOM 파싱을 중단한다.\n      2. link태그에 지정된 href 로 요청을 보내 css 파일을 다운로드 한다.\n      3. 다운받은 css파일을 DOM파싱과 동일한 과정을 거쳐 tree 구조의 객체들로 만들고 그것을 CSSOM(CSS Object Model)이라고 부른다.\n   3. 렌더트리\n      1. DOM과 CSSOM을 렌더트리로 결합한다.\n      2. 화면에 렌더링 되지 않는 태그( = script, link 및 css에 의해 비표출 되는 노드들)은 제외된다.\n      3. 생성된 렌더트리는 요소들의 레이아웃 계산에 사용되며 이를 통해 페인팅을 실행한다.\n3. 자바스크립트를 파싱하여 AST(Absctract Syntax Tree)를 생성하고, 바이트 코드로 변환하여 실행한다.\n   1. 자바스크립트의 파싱\n      1. DOM 생성 과정에서 script태그를 만나면 DOM 파싱을 중단하고 js를 파싱한다.\n      2. 파싱은 자바스크립트 엔진(V8, spiderMonkey, javaScriptCore 등)에서 일어난다.\n      3. 제어권을 넘겨받은 자바스크립트 엔진은 AST(Abstract Syntax Tree)를 생성한다.\n   2. 자바스크립트 소스 파싱의 순서\n      1. 토크나이징 : 토크나이저가 자바스크립트 소스를 토큰 단위로 분해한다.\n      2. 파싱 : 토큰들을 분석하여 AST를 생헌한다.\n      3. 바이트코드 생성 : AST를 인터프리터가 실행할 수 있는 바이트 코드로 변환 한다.\n         1. V8의 경우 자주 실행되는 코드는 터보팬(컴파일러)에 의해 Optimized Machine Code로 컴파일 되어 성능 최적화를 진행하며, 사용 빈도가 적어지만 Deoptimizing한다.\n      4. 실행 : 인터프리터가 바이트코드를 읽어 로직을 실행한다.\n4. 렌더트리를 기반으로 HTML요소의 레이아웃을 계산하고 브라우저 화면에 페인팅한다.\n\n### Reference\n\n- 자바스크립트 딥 다이브 (38장)\n","fileName":"2024-02-02","route":"2024-02-02"}},"__N_SSG":true},"page":"/posts/[postId]","query":{"postId":"2024-02-01"},"buildId":"Pq3gfwJpm76rkBK6R679W","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>