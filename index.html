<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({&#x27;gtm.start&#x27;:
new Date().getTime(),event:&#x27;gtm.js&#x27;});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!=&#x27;dataLayer&#x27;?&#x27;&amp;l=&#x27;+l:&#x27;&#x27;;j.async=true;j.src=
&#x27;https://www.googletagmanager.com/gtm.js?id=&#x27;+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,&#x27;script&#x27;,&#x27;dataLayer&#x27;,&#x27;GTM-K5DKF9QN&#x27;);</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.0/github-markdown-light.min.css" integrity="sha512-Pmhg2i/F7+5+7SsdoUqKeH7UAZoVMYb1sxGOoJ0jWXAEHP0XV2H4CITyK267eHWp2jpj7rtqWNkmEOw1tNyYpg==" crossorigin="anonymous" referrerPolicy="no-referrer"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/cc48ee3987fe3004.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/cc48ee3987fe3004.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-2e649cda4d7625ac.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-550f72cae410482c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-e6e0b507836a963c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-b50762c98fc23950.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/index-52add71f06ccd24d.js" defer="" crossorigin=""></script><script src="/_next/static/kb4CdM01kABZ1Ms35zfwO/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/kb4CdM01kABZ1Ms35zfwO/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K5DKF9QN" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="h-screen"><div class="navbar bg-base-100 sticky top-0 z-10"><div class="flex-1"><a class="btn btn-ghost text-xl">SunBlog</a></div><div class="flex-none gap-2"><div class="form-control"><div class="join"><div><div><input class="input input-sm input-bordered join-item max-w-[30vw]" placeholder="" value=""/></div></div><select class="select select-bordered join-item select-sm"><option value="tag">키워드</option><option value="title" selected="">제목</option></select><div class="indicator"><button class="btn join-item btn-sm">조회</button></div></div></div></div></div><main class="prose p-4 align-baseline overflow-y-scroll h-[95vh]"><div class=""><ul class="list-none p-0" style="display:ruby"><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.07</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">github</span><span class="text-blue-500 mr-2">blog</span><span class="text-blue-500 mr-2">구축기(4)</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">marked 라이브러리를 통한 markdown csr</div><div class="card-actions justify-end"><div class="badge ">next.js</div><div class="badge ">github blog</div><div class="badge ">gh-pages</div><div class="badge ">mdx</div><div class="badge ">marked</div><div class="badge ">highlights</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.06</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">github</span><span class="text-blue-500 mr-2">blog</span><span class="text-blue-500 mr-2">구축기(3)</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">mdx를 이용한 포스팅 작성</div><div class="card-actions justify-end"><div class="badge ">next.js</div><div class="badge ">github blog</div><div class="badge ">gh-pages</div><div class="badge ">mdx</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.05</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">github</span><span class="text-blue-500 mr-2">blog</span><span class="text-blue-500 mr-2">구축기(2)</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">github page를 배포하는 과정을 알아보자</div><div class="card-actions justify-end"><div class="badge ">next.js</div><div class="badge ">github blog</div><div class="badge ">gh-pages</div><div class="badge ">mdx</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.04</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">github</span><span class="text-blue-500 mr-2">blog</span><span class="text-blue-500 mr-2">구축기(1)</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">깃헙 블로그 제작과 프레임워크의 선택</div><div class="card-actions justify-end"><div class="badge ">next.js</div><div class="badge ">github blog</div><div class="badge ">gh-pages</div><div class="badge ">mdx</div><div class="badge ">깃헙 블로그</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.03</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">ShadowDOM에</span><span class="text-blue-500 mr-2">대한</span><span class="text-blue-500 mr-2">이해와</span><span class="text-blue-500 mr-2">활용</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">ShadowDOM을 활용한 CSS 은닉과 그 활용</div><div class="card-actions justify-end"><div class="badge ">shadow dom</div><div class="badge ">쉐도우 돔</div><div class="badge ">css 은닉</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.02</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">브라우저의</span><span class="text-blue-500 mr-2">렌더링</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">브라우저의 렌더링 순서</div><div class="card-actions justify-end"><div class="badge ">브라우저</div><div class="badge ">렌더링</div><div class="badge ">CSSOM</div><div class="badge ">AST</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.02.01</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">Rail</span><span class="text-blue-500 mr-2">모델</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">브라우저 사용자 경험에 대한 지표 Rail모델</div><div class="card-actions justify-end"><div class="badge ">Rail</div><div class="badge ">브라우저</div><div class="badge ">렌더링</div><div class="badge ">사용자 경험</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.01.31</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">DOM</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">Document Object Model에 대한 공부</div><div class="card-actions justify-end"><div class="badge ">DOM</div><div class="badge ">Document Object Model</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.01.30</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">V8엔진</span><span class="text-blue-500 mr-2">구동</span><span class="text-blue-500 mr-2">순서</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">V8엔진의 구동 순서에 대한 공부</div><div class="card-actions justify-end"><div class="badge ">V8</div><div class="badge ">AST</div><div class="badge ">브라우저</div></div></div></div></div></li><li class="inline-block"><div class="indicator"><div class="card m-4 hover:scale-105 transform transition-transform duration-300 border border-slate-600 cursor-pointer max-w-[70vw]"><span class="indicator-item badge badge-primary right-8">2024.01.29</span><div class="card-body"><h2 class="card-title flex-col"><div><span class="text-blue-500 mr-2">GraphQL은</span><span class="text-blue-500 mr-2">무엇인가</span></div></h2><div class="text-ellipsis max-w-[50vw] max-h-[10vh] overflow-hidden" style="display:-webkit-flex">GraphQL에 대한 공부</div><div class="card-actions justify-end"><div class="badge ">Graph QL</div><div class="badge ">그래프 큐엘</div></div></div></div></div></li></ul><div class="flex justify-center mt-4"><div class="join"><button class="join-item btn btn-lg btn-active">1</button><button class="join-item btn btn-lg ">2</button></div></div></div><footer class="footer footer-center p-4 bg-base-100 text-base-content"><aside><p>Copyright © 2024 - sun</p></aside></footer><div class="drawer absolute left-5 z-30 w-0 bottom-[5vh]"><input id="my-drawer" type="checkbox" class="drawer-toggle"/><div class="drawer-content"><label class="btn btn-circle swap swap-rotate" for="my-drawer"><input type="checkbox"/><svg class="swap-off fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z"></path></svg><svg class="swap-on fill-current" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512"><polygon points="400 145.49 366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49"></polygon></svg></label></div><div class="drawer-side"><label for="my-drawer" aria-label="close sidebar" class="drawer-overlay"></label><ul class="menu p-4 w-50 min-h-full bg-base-200 text-base-content"><li><a>Sun, 누구냐 너</a></li></ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"posts":[{"meta":{"title":"github blog 구축기(4)","desc":"marked 라이브러리를 통한 markdown csr","date":"2024.02.07","tags":["next.js","github blog","gh-pages","mdx","marked","highlights"]},"content":"\n# mdx로 작성한 파일의 정제\n\n\u003e mdx 작성한 meta 정보를 제거하고싶었다.\n\u003e 하지만 정보 제거에 어려움을 ...ㅠㅠ\n\u003e next.js 내부에서 모두 해결하고자 했으나, 일단 정적 페이지로 만든 페이지의 경우 SEO 적용도 가능하므로\n\u003e 굳이 여기에 시간 쓰지않고, markdown 문법을 react로 표출할 수 있도록 해주는 라이브러리를 찾기로 결정~!\n\n![240208-121859](/posts/2024-02-07/240208-121859.png)\n그림1. markdown 표출에 많이 쓰이는 npm library ( NPM trends )\n\n가장 사용량이 많고, 최근 없데이트가 되는걸로 보이는 marked를 이용하기로 결심\n\n## marked library\n\n\u003e 사용방법이 어렵지 않고, markdown 문법의 문자열을 집어넣어넣고, 그 결과를 innerHTML로 넣으면 간단하게 표출됨을 확인\n\n```tsx\n import { Marked } from 'marked';\n import { markedHighlight } from 'marked-highlight';\n import hljs from 'highlight.js';\n import 'highlight.js/styles/github.css';\n\n const marked = new Marked(\n   markedHighlight({\n     highlight(code, lang) {\n       const language = hljs.getLanguage(lang) ? lang : 'plaintext';\n       return hljs.highlight(code, { language }).value;\n     },\n   })\n );\n\n const renderer = new marked.Renderer();\n\n renderer.code = function (code: string) {\n   return '\u003cdiv class=\"mockup-code border bg-[#f6f8fa]\" style=\"width:90%;margin:auto;margin-bottom:20px;\"\u003e\u003cpre style=\"margin-bottom:0;padding:0;\"\u003e\u003ccode\u003e\\n${marked.parseInline(code)}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e';\n };\n\n \u003cdiv\n   className='markdown-body min-h-[58vh] px-6 max-w-[100vw]'\n   dangerouslySetInnerHTML={{\n     __html: marked.parse(post.content, {\n       renderer,\n     }),\n }}\u003e\n```\n\ncode box 영역에 highlight를 적용하고 daisyUI에서 제공하는 mockup-code 를 활용하고 싶어 위와같이 짰다.\n![240208-122304](/posts/2024-02-07/240208-122304.png)\n그림2. daisyUI mockup code UI\n\n이렇게 하면 next.js에서 mdx로 작성한 페이지의 meta정보와 별개로 markdown 문법을 내 입맛에 맞게 표출 할 수 있게 되었다.\n","fileName":"2024-02-07","route":"2024-02-07"},{"meta":{"title":"github blog 구축기(3)","desc":"mdx를 이용한 포스팅 작성","date":"2024.02.06","tags":["next.js","github blog","gh-pages","mdx"]},"content":"\n# 포스팅의 meta정보 입력\n\n- 포스팅의 meta정보를 통해 포스트 리스트 표출시 정보를 표출해야 한다.\n\n![240207-232027](/posts/2024-02-06/240207-232027.png)\n그림1. .mdx 의 meta정보\n\n\u003e getStaticProps로 post가져오기\n\n```typescript\nimport fs from 'fs';\nimport matter from 'gray-matter';\nimport path from 'path';\n\nexport function getPostIds() {\n  const files = fs\n    .readdirSync(path.join('posts'))\n    .filter((filename) =\u003e filename.endsWith('.mdx'))\n    .map((filename) =\u003e filename.replaceAll('.mdx', ''));\n  return files;\n}\n\nexport function getPostById(postId: string) {\n  const markdownWithMeta = fs.readFileSync(\n    path.join('posts', postId + '.mdx'),\n    'utf-8'\n  );\n  const { data: meta, content } = matter(markdownWithMeta);\n  return {\n    meta: {\n      title: meta['title'] ?? '',\n      desc: meta['desc'] ?? '',\n      date: meta['date'] ?? '',\n      tags: meta['tags'] ?? [],\n    },\n    content,\n    fileName: postId,\n    route: postId,\n  };\n}\n\nexport const getStaticProps: GetStaticProps = async ({ params }) =\u003e {\n  const { postId = '' } = params ?? { postId: '' };\n  const postIds = getPostIds();\n  const idx = postIds.findIndex((_postId) =\u003e postId === _postId);\n  let prev = null,\n    post = null,\n    next = null;\n  for (let i = 0; i \u003c postIds.length; i++) {\n    const _postId = postIds[i];\n    if (_postId === postId) {\n      prev = i === 0 ? null : getPostById(postIds[i - 1]);\n      post = getPostById(_postId);\n      next = i + 1 === postIds.length ? null : getPostById(postIds[i + 1]);\n      break;\n    }\n  }\n\n  return {\n    props: {\n      prev,\n      post,\n      next,\n    },\n  };\n};\n```\n\nroot folder에 posts 폴더를 만들고 그 내부에 포스트들을 mdx파일로 생성하고, 그 파일들을 읽도록 했다.\n![240208-020424](/posts/2024-02-06/240208-020424.png)\n그림2. folder 구조 및 posts 폴더\n\n이때 폴더명은 포스트가 작성된 날짜를 기준으로 했고, 그 날짜는 mdx 내부에 적어놓은 meta와 동일하게 맞추었다.\n","fileName":"2024-02-06","route":"2024-02-06"},{"meta":{"title":"github blog 구축기(2)","desc":"github page를 배포하는 과정을 알아보자","date":"2024.02.05","tags":["next.js","github blog","gh-pages","mdx"]},"content":"\n# 블로그 글 작성 및 표출하는 방법은?\n\n- 기본적으로 포스팅은 markdown으로 작성하도록 하고싶다.\n  - 작성 과정에서 markdown으로 글을 확인하고, 그대로 표출되도록 하고싶기 때문\n- 별도 서버 없이 작성한 post markdown파일을 github에 저장하고, 그걸 그대로 표출 하고싶다.\n\n=\u003e mdx 파일로 작성하고, meta 정보를 parsing하여 글 목록에 표출하도록 하고, 표스팅 내용은 dynamic routing으로 확인할 수 있는 구조로 짜도록 하자!\n\n![240205-212509](/posts/2024-02-05/240205-212509.png)\n그림1. src 폴더 하부 구조\n\n기본적인 폴더 구조는 다음과 같이\n/pages 폴더 밑에 [postId].tsx를 두어 dynamic routing이 가능하도록 했다.\n\n# 본격 github page 배포\n\n\u003e gh-pages library를 사용!\n\u003e [gh-pages npm repository](https://www.npmjs.com/package/gh-pages)\n\ngithub page에 내가 작성한 markdown을 포스팅으로 표출하기 위해\ngh-pages를 활용하도록 하고 deploy 스크립트는 다음과 같이 짰다.\n\n```bash\n # package.json\n \"deploy\": \"next build \u0026\u0026 touch out/.nojekyll \u0026\u0026 gh-pages -d out --dotfiles\",\n```\n\n이제 yarn deploy 명령어를 통해  \n 연결한 git repository의 gh-pages 브랜치에 빌드된 결과물이 올라가게 된다.  \n 이때 github repository 설정에서 표출할 branch를 gh-pages로 변경시켜준다.\n\n![240205-213613](/posts/2024-02-05/240205-213613.png)\n그림2. github repository settings\n\n![240205-213633](/posts/2024-02-05/240205-213633.png)\n그림3. gh-pages 브랜치를 github page 메인브랜치로 이용하도록 변경\n\n위와같이 설정했다면\nyarn deploy 명령어를 통해 github page가 배포됨을 알 수 있다.\n","fileName":"2024-02-05","route":"2024-02-05"},{"meta":{"title":"github blog 구축기(1)","desc":"깃헙 블로그 제작과 프레임워크의 선택","date":"2024.02.04","tags":["next.js","github blog","gh-pages","mdx","깃헙 블로그"]},"content":"\n# 왜 깃헙 블로그로 이사를 했나\n\n이전에는 notion을 썼다. 노션 자체 기능도 많고, 글 작성도 편리했지만  \n 직접 react로 블로그를 꾸미고, 기능을 추가하는것도 재밌을것 같아 이사를 결심했다.\n\n## 깃헙 블로그 제작을 위해 고려했던것\n\n- static site로 제작하여 별도의 서버구축이 필요없어야 한다.\n- React 문법을 활용하여 작성이 편리하고, 향후 확장에도 용이해야 한다.\n- markdown을 이용해 작성이 가능하고, 표출이 되어야 한다.\n\n## 프레임워크의 선택\n\n깃험블로그를 찾아보니 next.js 와 gatsby 두가지 프레임워크를 많이 채택하는듯 했다.\n사실 두가지를 보자마자 next.js로 구축하고 싶었다.\n애초에 next.js는 익숙하기도 하고, 별다른 러닝커브 없이 빠르게 구축하고 싶었기 때문이다.\n\n따라서 next.js로 선택!\n\n# 본격적 깃헙페이지 제작\n\n## github page 생성\n\n깃헙페이지는 https://{깃헙아이디}.github.io 형태로 이용 할 수 있다.  \n따라서 이 이름으로 repository를 생성한다.\n\n![240203-225036](/posts/2024-02-04/240203-225036.png)  \n( 깃헙아이디 ).github.io 로 레포지토리 생성!!\n\n## next.js 생성 및 설정\n\n```bash\n$ npx create-next-app@latest\n```\n\n```mjs\n// next.config.mjs\nimport createMDX from '@next/mdx';\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // static page들로만 구성하도록 하기 위해 export 설정 추가\n  output: 'export',\n  // github page는 정적 페이지로 구성되기때문에 image에 대하 optimized를 꺼준다\n  images: {\n    unoptimized: false,\n  },\n  assetPrefix: '/',\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n};\n\nconst withMDX = createMDX();\n\nexport default withMDX(nextConfig);\n```\n\n위와같이 설정하면 기본적으로 github page에 정적 페이지로 표출될 수 있는 기본 설정이 마무리된다.\n","fileName":"2024-02-04","route":"2024-02-04"},{"meta":{"title":"ShadowDOM에 대한 이해와 활용","desc":"ShadowDOM을 활용한 CSS 은닉과 그 활용","date":"2024.02.03","tags":["shadow dom","쉐도우 돔","css 은닉"]},"content":"\n# Shadow DOM이란 무엇인가?\n\n- cssom tree를 따로 가지는 html element\n- [shadowDOM mdn 설명 보러가기](https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_shadow_DOM)\n  ![240203-163855](/posts/2024-02-03/240203-163855.png)\n  그림1. shadowDOM cssom tree구조도 ( 출처: mdn)\n\n  \u003e shadow dom을 활용하면 shadow dom 내/외부의 css가 서로 간섭없이 사용이 가능하다  \n  \u003e 만약 특정 dom element가 내/외부 의 css와 연관없이 동작하도록 하고 싶다면 shadowDOM을 활용하면 된다\n\n  ```javascript\n  const openShadowRoot = (dom: HTMLElement) =\u003e {\n    if (dom?.shadowRoot) return dom.shadowRoot;\n    const shadowRoot = dom.attachSadow({\n      mode: 'open',\n    });\n    return shadowRoot;\n  };\n\n  const shadowRoot = openShadowRoot(document.querySelector('#root'));\n  console.log(shadowRoot);\n  ```\n\n  위와같이 shadow DOM으로 활용하고자 하는 dom element에 attachShadow를 해주면\n  shadow-root가 오픈된다.\n  ![240203-164510](/posts/2024-02-03/240203-164510.png)\n  ![240203-164702](/posts/2024-02-03/240203-164702.png)\n\n  \u003chr /\u003e\n\n  ## shadowDOM의 활용 ( React )\n\n  이렇게 만든 shadowDOM을 리액트 환경에서 한번 활용해보자\n\n```typescript\n// ShadowDOM.tsx\nimport { ReactNode, useRef, useState, ReactPortal, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport default function ShadowDOM({ children }: { children?: ReactNode }) {\n  const divRef = useRef\u003cHTMLDivElement\u003e(null);\n  const [portal, setPortal] = useState\u003cReactPortal | null\u003e(null);\n\n  useEffect(() =\u003e {\n    if (!divRef.current || divRef?.current?.shadowRoot) return;\n    const shadowRoot =\n      divRef?.current?.shadowRoot ??\n      divRef.current.attachShadow({ mode: 'open' });\n    const _portal = createPortal(children, shadowRoot);\n    setPortal(_portal as ReactPortal);\n  }, [children]);\n\n  return \u003cdiv ref={divRef}\u003e{portal}\u003c/div\u003e;\n}\n\n// Home.tsx\nimport ShadowDOM from '@/components/common/ShadowDOM';\n\nexport default function Home() {\n  return (\n    \u003cShadowDOM\u003e\n      \u003cstyle\u003e\n        {'div { background-color: red; width: 200px; height: 300px;}'}\n      \u003c/style\u003e\n      \u003cdiv\u003ehome\u003c/div\u003e\n    \u003c/ShadowDOM\u003e\n  );\n}\n```\n\n![240203-182312](/posts/2024-02-03/240203-182312.png)\n![240203-182137](/posts/2024-02-03/240203-182137.png)\n\n위와같이 home 컴포넌트의 background-color가 외부에 전파되지 않는것을 확인할 수 있다.\n\n\u003ciframe\n  width='300'\n  height='400'\n  src='/home'\n  frameborder='0'\n  allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\n  allowfullscreen\u003e\u003c/iframe\u003e\n예시1. shadowDOM을 통한 css 은닉 화면 (iframe)\n","fileName":"2024-02-03","route":"2024-02-03"},{"meta":{"title":"브라우저의 렌더링","desc":"브라우저의 렌더링 순서","date":"2024.02.02","tags":["브라우저","렌더링","CSSOM","AST"]},"content":"\n# 브라우저의 렌더링 순서\n\n1. HTML, CSS, Javascript, static files 등의 리소스를 요청 하고 응답 받는다.\n2. HTML, CSS를 파싱하여 DOM, CSSOM을 생성하여 렌더트리를 생성한다.\n   1. DOM 파싱\n      1. 서버에서 HTML을 바이트(2진수)형태로 응답받는다.\n      2. meta tag의 charset 어트리뷰트를 통해 인코딩 방식을 인식하고 해당 인코딩 방식으로 문자열 치환한다.\n      3. 해당 문자열을 문법적 최소 의미 단위를 갖는 토큰으로 분해한다.\n      4. 분해된 토큰을 기반으로 노드 객체를 생성한다.\n      5. 생성된 노드들은 트리구조로 되어있으며 이러한 구조를 DOM(Document Obejct Model)이라고 부른다.\n   2. CSSOM 파싱\n      1. DOM 생성( HTML 파싱 )중 link tag를 만나면 DOM 파싱을 중단한다.\n      2. link태그에 지정된 href 로 요청을 보내 css 파일을 다운로드 한다.\n      3. 다운받은 css파일을 DOM파싱과 동일한 과정을 거쳐 tree 구조의 객체들로 만들고 그것을 CSSOM(CSS Object Model)이라고 부른다.\n   3. 렌더트리\n      1. DOM과 CSSOM을 렌더트리로 결합한다.\n      2. 화면에 렌더링 되지 않는 태그( = script, link 및 css에 의해 비표출 되는 노드들)은 제외된다.\n      3. 생성된 렌더트리는 요소들의 레이아웃 계산에 사용되며 이를 통해 페인팅을 실행한다.\n3. 자바스크립트를 파싱하여 AST(Absctract Syntax Tree)를 생성하고, 바이트 코드로 변환하여 실행한다.\n   1. 자바스크립트의 파싱\n      1. DOM 생성 과정에서 script태그를 만나면 DOM 파싱을 중단하고 js를 파싱한다.\n      2. 파싱은 자바스크립트 엔진(V8, spiderMonkey, javaScriptCore 등)에서 일어난다.\n      3. 제어권을 넘겨받은 자바스크립트 엔진은 AST(Abstract Syntax Tree)를 생성한다.\n   2. 자바스크립트 소스 파싱의 순서\n      1. 토크나이징 : 토크나이저가 자바스크립트 소스를 토큰 단위로 분해한다.\n      2. 파싱 : 토큰들을 분석하여 AST를 생헌한다.\n      3. 바이트코드 생성 : AST를 인터프리터가 실행할 수 있는 바이트 코드로 변환 한다.\n         1. V8의 경우 자주 실행되는 코드는 터보팬(컴파일러)에 의해 Optimized Machine Code로 컴파일 되어 성능 최적화를 진행하며, 사용 빈도가 적어지만 Deoptimizing한다.\n      4. 실행 : 인터프리터가 바이트코드를 읽어 로직을 실행한다.\n4. 렌더트리를 기반으로 HTML요소의 레이아웃을 계산하고 브라우저 화면에 페인팅한다.\n\n### Reference\n\n- 자바스크립트 딥 다이브 (38장)\n","fileName":"2024-02-02","route":"2024-02-02"},{"meta":{"title":"Rail 모델","desc":"브라우저 사용자 경험에 대한 지표 Rail모델","date":"2024.02.01","tags":["Rail","브라우저","렌더링","사용자 경험"]},"content":"\n# Rail 모델\n\n- Rail은 브라우저에서의 성능에 대해 생각할 수 있도록 해주는 사용주 중심 성능 모델\n- 4가지 웹앱의 생명주기를 통해 성능 지표를 나타냄(response, animation, idle, load)\n- 구체적 목표와 지침을 지정하여 성능 측정 항목으로 이용할 수 있도록 함\n\n![240203-210333](/posts/2024-02-01/240203-210333.png)\n\n출처: https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Rail모델에서 바라본 사용자 경험에 대한 기준\n\n| 0~16ms | - 사용자는 초당 60개의 프레임이 렌더링되는걸 부드럽다고 인식한다\n\n- 브라우저에서 새 프레임을 그리는데는 16ms가 걸린다.\n- | 사용자가 애니메이션이 매우 매끄럽다고 느낌 |\n  | ------------------------------------------ | ---------------------------------------------- |\n  | 0~100ms                                    | - 이 정도 응답에선 즉각적 반응이 일어난다 느낌 |\n- 하지만 더 길어지면 동작 ↔ 응답 이 끊어진다는 느낌을 받음 |\n  | 100~1,000ms | - 자연스럽고 지속적 작업의 일부로 받아들일 수 있는 수준\n- 대부분의 웹앱의 상태 |\n  | 1,000ms ~ 10,000ms | - 1초를 초과하므라 사용자는 작업에 집중을 잃게됨 |\n  | 10,000ms 이상 | - 사용자 이탈 |\n\n# Response: 50ms 미만의 이벤트 처리 목표\n\n- 목표 : 사용자 입력에 대한 interaction이 100ms이내에 완료되어 전달 될 수 있도록(즉각적이다는 느낌)\n- 지침\n  - 터치, 스크롤등 연결되는 동작은 제외하고, 클릭, 토글등의 이벤트에 적용\n  - 리소스가 많이 필요한 작업이라면 백그라운드로 동작할 수 있도록(사용자 경험을 차단하지 않도록)\n  - 50ms를 넘기는 응답에 대해선 피드백을 제공할 수 있도록한다.\n\n\u003e 100ms 응답을 위해선 고작 50ms의 여유만 존재한다.\n\n목표가 100ms인 응답을 주려고 할 때, 개발자에게 가용한 시간은 50ms에 불과하다.\n\n목표하는 task처리외에도 입력에 대한 입력을 수용하고, 응답을 표출하기위한 처리시간 또한 필요하므로 실제 사용할 수 있는 시간은 50ms정도!\n\n![240203-210345](/posts/2024-02-01/240203-210345.png)\n\n출처 : https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Animation : 10ms안에 프레임 생성\n\n- 목표\n  - 애니메이션을 각 10ms 프레임 이하로 생성\n  - 각 프레임의 최대예산은 16ms지만 브라우저가 프레임을 렌더링하는 시간이 필요하므로 10ms만 가용\n  - 시각적 부드러움이 목표!\n- 지침\n  - 애니메이션 처리와 같이 높은 연산이 필요한 작업에는 다른 작업을 포함하지 않는다.\n  - 스크롤, 로드표시 와 같은 시각적 애니메이션등을 포함하는 개념들에 적용\n  - 렌더링 성능의 원리는 적극 참조한다.\n\n# Idle: 유휴시간 극대화\n\n- 목표\n  - idle time을 최대화하여 사용자의 입력에 50ms이내 응답할 수 있도록 한다.\n- 지침\n  - 초기 페이지 로드를 가볍게 하고, 유휴 시간에 나머지를 로드하도록 한다.\n  - 50ms를 넘는 작업은 다른 사용자 입력에 대한 응답에 방해가 될 수 있으므로, 그 이내 시간에 할 수 있도록 한다.\n  - 유휴 작업중 사용자 입력이 있다면, 우선순위에 따라 작동하도록 한다.\n\n# Load : 최대 5초 이내 콘텐츠 전달 후 상호작용 준비\n\n- 목표\n  - slow 3g상황에서도 5초 이내에 콘텐츠를 전달하고 상호작용에 준비할 수 있도록 한다.\n- ## 지침\n\n# Rail 측정도구\n\n- chrome devtools\n- Lighthouse\n- WebPageTest\n\n# Referrence\n","fileName":"2024-02-01","route":"2024-02-01"},{"meta":{"title":"DOM","desc":"Document Object Model에 대한 공부","date":"2024.01.31","tags":["DOM","Document Object Model"]},"content":"\n# 노드\n\n\u003e HTML요소와 노드 객체\n\n- HTML요소 : HTML문서를 구성하는 개별 요소\n  - HTML요소의 구조\n    - 시작태그(start tag)\n    - 어트리뷰트 명 (attribute name)\n    - 어트리뷰트 값 (attribute value)\n    - 콘텐츠 (contents)\n- HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.\n\n\u003e 노드 타입의 종류\n\n- 문서 노드( document node )\n  - DOM트리 최상에 존재하는 루트 노드\n  - document 객체를 가리킨다.\n- 요소 노드 (element node)\n  - HTML요소를 가리키는 객체\n- 어트리뷰트 노드 (attribute node)\n  - HTML요소의 attribute를 가리키는 객체\n  - HTML 요소 노드의 sibling관계를 갖는다.\n  - 부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.\n- 텍스트 노드 (text node)\n  - element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드\n\n\u003e 노드 객체의 상속구조\n\n노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.\n\n노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.\n\n![240203-210458](/posts/2024-01-31/240203-210458.png)\n\n그림. 노드객체의 상속구조(구글 검색)\n\n위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.\n\n이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.\n\n```jsx\nconst input = document.createElement('input');\n/*\n\t최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위\n*/\n```\n\n\u003e Element node의 텍스트 조작\n\n1. nodeValue\n\n   1. nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.\n\n   ```jsx\n   \u003cdiv id='text'\u003ehello\u003c/div\u003e;\n   const hello = document.querySelector('#text');\n   console.log(hello.nodeValue); // null\n   console.log(hello.firstChild.nodeValue); // hello\n   ```\n\n2. textContent\n\n   1. getter와 setter가 모두 존재하는 접근자 프로퍼티.\n   2. textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)\n   3. ```jsx\n      \u003cdiv id='text'\u003e\n        hello \u003cspan\u003eworld\u003c/span\u003e\n      \u003c/div\u003e;\n      const hello = document.querySelector('#text');\n      console.log(hello.textContent); // hello world\n      ```\n\n   4. element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.\n   5. innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.\n      1. innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.\n      2. css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.\n\n   \u003e 어트리뷰트\n\n   HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.\n\n   - HTML어트리뷰트 vs DOM프로퍼티\n     - 어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.\n     - 따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.\n     - ![240203-210509](/posts/2024-01-31/240203-210509.png)\n     - DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!\n   - HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계\n     - id attribute 와 id property 는 1대1대응\n     - value attribute ⇒ 초깃값, value property ⇒ 최신값\n     - class attribute ⇒ className, classList와 대응\n     - for attribute ⇒ htmlFor 프로퍼티와 1대1 대응\n     - td요소의 colspan attribute는 대응하는 프로퍼티 없음\n     - textContent 프로퍼티는 대응하는 어트리뷰트 없음\n     - attribute는 대소문자x, property는 카멜케이스\n     -\n\n# 레퍼런스\n\n1. 모던 자바스크립트 deep dive(p.677)\n","fileName":"2024-01-31","route":"2024-01-31"},{"meta":{"title":"V8엔진 구동 순서","desc":"V8엔진의 구동 순서에 대한 공부","date":"2024.01.30","tags":["V8","AST","브라우저"]},"content":"\n\u003e v8엔진 구동 순서\n\n1. 소스코드 파싱\n2. AST(Abstract Syntax Tree) 추상 구문 트리로 변환 → 컴파일러들이 이용하는 자료구조\n3. 자바스크립트 바이트코드로 변환(인터프리터 Ignition 이용)\n   1. Ignition : v8부터 이용되는 인터프리터로 이전의 Full-codegen(인터프리터)를 대체한다.\n\n      (인터프리터 : 소스코드를 바로 실행하는 환경 )\n4. 바이트 코드 실행\n   1. 자주 사용하는 코드는 TurboFan으로 보내 최적화된 코드로 재컴파일(Optimized Machine Code)\n   2. 사용률이 떨어지면 deoptimized\n5.\n\n\u003e 레퍼런스\n\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n","fileName":"2024-01-30","route":"2024-01-30"},{"meta":{"title":"GraphQL은 무엇인가","desc":"GraphQL에 대한 공부","date":"2024.01.29","tags":["Graph QL","그래프 큐엘"]},"content":"\n\u003e GraphQL이란\n\n\u003caside\u003e\n💡 GraphQL은 쿼리언어이자 서버측 런타임\n\n\u003c/aside\u003e\n\n그래프 큐엘은 데이터를 가져오는데 쿼리를 이용하도록 합니다.\n\n\u003e runtime\n\ngraphQL api는 서버에서 runtime에 실행된다.\n\n데이터의 출처에 구애받지 않고 runtime에 데이터 패칭이 가능하다.\n\n\u003e GraphQL 구현 순서\n\n1. GraphQL schema design\n2. resolver ↔ data source connection\n3. GraphQL query fetching\n\n\u003e GraphQL 의 특징\n\n1. 성능\n   1. 오버패칭 방지\n   2. 언더패칭 방지: rest API의 경우 서로 다른 schema 또는 data source의 경우 여러번의 api콜로 각각 언더패칭된 데이터를 front-side에서 조합해야 하는 경우가 있다. graphQL은 이런 문제를 해결해준다.\n2. 개발자 편의성\n   1. 계층적 스키마 구조: 그래프 구조와 선언적 구조를 통해 쿼리를 직관적으로 이해할 수 있다.\n   2. 타입 안정성: graphQL은 그 자체로 스키마 구조를 가지므로 프론트 사이드와 서버 사이드의 타입이 상호 동일해야만 통신이 가능하므로 그 자체로 타입안정성을 보장한다.\n3. 구조\n   1. 클라이언트 개발의 서버 의존성 분리: restAPI처럼 서버사이드에서 원하는 API를 개발해 줄 때까지 기다려야 하는 업무의존성을 없앨 수 있다.\n   2. 단일 정보출처: 프론트 사이드에선 데이터들 마다 API를 언더패칭하여 조합하던 restAPI와 달리 조합이 되어 불려오도록 하는 단일 출처만 알면된다.\n4. 훌륭한 커뮤니티\n   1. 훌륭한 도구들: apollo client, apollo studio 등 다양한 도구들이 완비되어있다.\n   2. 광범위한 이용: 여러 사이트 들에서 graphQL을 이용중이다.\n","fileName":"2024-01-29","route":"2024-01-29"},{"meta":{"title":"리액트 쿼리 tkdodo blog 글 번역","desc":"리액트 쿼리 공식 사이트에 있는 블로그 글을 스터디하여 공유","date":"2024.01.28","tags":["react query","리액트 쿼리"]},"content":"\nApollo Client의 등장으로 fetch library( 데이터 가져오기 라이브러리 )가 redux와 같은 전역 상태관리 라이브러리를 대체할 수 있다는 의견이 확산되었다.\n\n# # 1. 실용적 리액트 쿼리\n\n\u003e 클라이언트 상태 VS 서버 상태\n\nApollo는 data fetching 뿐만 아니라 서버에서 보낸 데이터( fetching해온 서버 데이터 )에 대한 캐시 기능까지 제공한다. 즉 useQuery hook을 사용하여 fetching한 후 캐싱된 데이터를 여러 Component에서 이용할 수 있도록 해준다.\n\n이전의 클라이언트 앱들은 서버의 상태( 표시하고자 하는 데이터 )를 소유하지 않고, 가장 최신의 자료를 가져와서 표출하는데 그치고 있었다. 항상 데이터의 소유자는 서버였다.\n\n\u003e React-Query\n\n리액트 쿼리는 Fronet-end단에서도 data fetching과 loading, error state를 포함한 상태 전역을 단순하게 관리하도록 하고자 했다. REST api처럼\n\nreact-query는 refetchOnWindowFocus를 통해 다른 창에 갔던 focus가 다시 돌아오면 서버에 데이터를 요청하여 최신상태의 데이터를 가져옵니다. 이를 통해 트리거된 Component의 표출된 데이터가 변경되며 이 모든 과정은 loading spinner가 없이 자동으로 이루어집니다.\n\n1. StaleTime: query data가 최신(fresh) → 오래된(stale)상태가 되는데 까지 걸리는 시간을 뜻합니다. 쿼리의 데이터가 최신이라고 판단될 경우 항상 cache에 있는 데이터만을 표출하도록 합니다( 네트워크 요청 없이 )\n2. CacheTime: 비활성 쿼리가 캐시에서 제거 될때까지의 시간을 뜻합니다(default = 5min). 해당 쿼리에 등록된 관찰자(observer)가 없는 경우 즉시 쿼리가 비활성 상태가 됩니다.\n\n⇒ 대부분의 경우 staleTime을 조정하도록하고, cacheTime은 조정할 필요가 거의 없습니다.\n\n# # 2. 리액트 쿼리의 데이터 변환\n\n\u003e 데이터의 변환\n\nREST를 이용하여 데이터를 불러올 때, 화면에 표출하기 위한 형태로 데이터를 가공할 수 있는 지점은 3 + 1군데가 존재한다.\n\n1. back-end ( +1에 해당하며 front-end의 담당이 아닌 구역)\n   1. 백엔드단에서 애초에 필요한 데이터 형태로 가공하여 데이터를 전달해주는 방법\n   2. 장점\n      1. 표출에 완전히 부합하는 형태 그대로 데이터를 받을 수 있다.\n   3. 단점\n      1. 프론트앤드의 영역이 아니다\n2. queryFn\n   1. useQuery(${QUERY_KEY}, ${queryFn})\n      1. 여기서 queryFn을 통해 받아온 데이터를 가공하여 cache에 저장할 수 있다.\n   2. 장점\n      1. 데이터 처리 위치가 백엔드에 가깝다 ( front-end component ↔ cache ↔ back-end )\n   3. 단점\n      1. fetching을 통해 받아온 데이터를 queryFn에서 가공하여 cache에 저장하므로 원래 fetching해온 데이터 원형을 나중에 다시 확인할 수 없다.\n3. Render\n   1. react component render단위에서 해당 데이터를 가공하는 방법\n   2. 장점\n      1. useMemo를 통해 최적화가 가능하다.\n   3. 단점\n      1. 데이터의 정확한 구조를 devtools를 통해 확인하기가 어렵다\n      2. 구문이 복잡하다\n4. 선택 옵션\n   1. useQuery( ${QUERY_KEY}, ${queryFn}, ${select_option} )에서 select_option 객체에서 select프로퍼티에 데이터 정제를 지정하여 사용할 수 있다.\n   2. 장점\n      1. 데이터의 원형을 저장해놓고 필요에 따라 정제하여 쓸 수 있다\n      2. 위 3가지 중 가장 좋은 방식으로 고려된다.\n\n# # 3. 리액트 쿼리의 렌더링 최적화\n\n\u003e isFetching 전환\n\nuseQuery로 데이터를 가져올 경우 isFetching 상태가 true → false로 변환되는 과정에서 2번의 렌더링을 거치게 된다.\n\n\u003e notifyOnChangeProps: ‘data’\n\n이러한 낭비를 줄이기 위해 select option 객체에 notifyOnChangeProps 프로퍼티에 ‘data’를 값으로 주어 실제적으로 데이터가 변환되었을 경우에만 렌더링이 일어나도록 할 수 있다.\n\n\u003e 동기화유지\n\n그러나 위와같이 data값만을 트리거로 데이터의 표출을 하게 될 경우 해당 fetching이 error일 경우에 대한 표출 여부를 트리거 할 수 없다.\n\n```jsx\n// 🚨 will track all fields\nconst { isLoading, ...queryInfo } = useQuery(...)\n\n// ✅ this is totally fine\nconst { isLoading\n```\n\n```jsx\n\nconst queryInfo = useQuery(...)\n\n// 🚨 will not corectly track data\nReact.useEffect(() =\u003e {\n    console.log(queryInfo.data)\n})\n\n// ✅ fine because the dependency array is accessed during render\nReact.useEffect(() =\u003e {\n    console.log(queryInfo.data)\n}, [queryInfo.data])\n```\n\n\u003e 구조 공유\n\n```jsx\n[\n  { id: 1, name: 'Learn React', status: 'active' },\n  { id: 2, name: 'Learn React Query', status: 'todo' },\n];\n```\n\n```jsx\n[\n  -{ id: 1, name: 'Learn React', status: 'active' },\n  +{ id: 1, name: 'Learn React', status: 'done' },\n  { id: 2, name: 'Learn React Query', status: 'todo' },\n];\n```\n\n위와 같은 형식으로 todo 리스트가 있었고, 그 중에서 id가 1인 todo의 데이터가 변경되었을 경우 react-query는 나머지 데이터 ( id = 2 )의 데이터는 이전의 참조를 그대로 유지한다. 따라서 id가 2인 todo를 참조하는 ( ex : select option을 이용) component는 id가 1인 todo의 데이터가 변경되었어서 re-rendering되지 않는다.\n\n하지만 해당 query-key에 저장된 데이터가 아주 클 경우 JSON 직렬화를 통해 queryFn으로 변형된 데이터가 이전의 데이터와 변경사항이 있는지 파악해야 하기 때문에 병목현상이 생길 수 있다.\n\n따라서 이러한 최적화가 필요하지 않다면 ( 받아온 데이터가 실제로 변경된 부분만 교체하도록 하여 변경되지 않은 데이터를 참조하고 있는 component들의 re-rendering을 방지하는 최적화 ) structureSharing: false를 통해 끌 수 있다.\n\n# #4. React-query 상태 확인\n\n리액트 쿼리는 쿼리의 상태 필드에 쉽게 access 할 수 있도록 해준다. 따라서 현재 실행중인 query가 어떤 상태인지( 로딩, 에러, 패칭 등 ) 쉽게 파악이 된다. react-query에서 노출해주는 플래그값는 다음과 같다.\n\n- success: 쿼리가 성공했으며, 데이터가 있음.\n- error: 쿼리가 실패 했으며, 오류가 설정되었음.\n- loading: 쿼리를 처음으로 로드중이며, 현재 데이터가 없음.\n- idle: 쿼리 비활성 상태 ( 로드 된 적 없음 )\n\n```jsx\nconst todos = useTodos();\n\nif (todos.isLoading) {\n  return 'Loading...';\n}\nif (todos.error) {\n  return 'An error has occurred: ' + todos.error.message;\n}\n\nreturn \u003cdiv\u003e{todos.data.map(renderTodo)}\u003c/div\u003e;\n```\n\n리액트 쿼리에선 re-fetching 메커니즘이 없지만, 리액트 쿼리에선 refetchOnMount, refetchOnWindowFocus, refetchOnReconnet의 개념을 제공하여 데이터 refetch를 백그라운드에서 실행할 수 있도록해줍니다. ( 그러나 백그라운드 refetch의 실패시 혼란스러운 ux가 발생할 가능성이 있다. )\n\n\u003e 백그라운드 오류\n\n```jsx\n{\n  \"status\": \"error\",\n  \"error\": { \"message\": \"Something went wrong\" },\n  \"data\": [{ ... }]\n}\n```\n\nfetch가 실패한 쿼리의 데이터 상태는 다음과 같을 수 있다. 위와같이 fetch가 실패하였음에도, 이전에 가지고 있던 data는 삭제되지 않고 가지고 있을 수 있으며, stale-while-revalidate 캐싱 메커니즘을 수용한 결과로 볼 수 있다. (re-fetch작업은 default로 3번까지 실행된다.)\n\n# #5. React-query 테스트하기\n\n# #6. React-Query \u0026 TypeScript\n\n```jsx\nexport function useQuery\u003c\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey\n\u003e\n```\n\n\u003e 네가지 generic\n\n- TQueryFnData: queryFn에서 반환된 유형.\n- TError: queryFn에서 예상되는 오류 유형\n- TData: 데이터 속성. (queryFn에서 반환하는 데이터 유형과 다를 수 있음)\n- TQueryKey: queryFn에 전달된 queryKey를 사용하는 경우에만 사용하는 유형\n\n\u003e 타입 추론\n\n```jsx\nfunction identity\u003cT\u003e(value: T): T {\n  return value;\n}\n\n// 🚨 no need to provide the generic\nlet result = identity \u003c number \u003e 23;\n\n// ⚠️ or to annotate the result\nlet result: number = identity(23);\n\n// 😎 infers correctly to `string`\nlet result = identity('react-query');\n```\n\n\u003e\n\n\u003e 부분 타입 인수 추론\n\n```jsx\nfunction useGroupCount() {\n  return useQuery\u003cGroup[], Error\u003e('groups', fetchGroups, {\n    select: (groups) =\u003e groups.length,\n    // 🚨 Type '(groups: Group[]) =\u003e number' is not assignable to type '(data: Group[]) =\u003e Group[]'.\n    // Type 'number' is not assignable to type 'Group[]'.ts(2322)\n  })\n}\n```\n\n```jsx\nfunction useGroupCount() {\n  // ✅ fixed it\n  return useQuery\u003cGroup[], Error, number\u003e('groups', fetchGroups, {\n    select: (groups) =\u003e groups.length,\n  })\n}\n```\n\n위의 경우 useQuery에서 select에 대한 type을 지정해주지 않았기 때문에 타입을 추론할 수 없다.\n\n아래의 경우 number로 select부의 타입을 선언해주었기 때문에 해당 타입으로 이용이 된다.\n\n\u003e 모든것을 추론\n\n```jsx\nfunction useGroups() {\n  // 🚨 data will be `any` here\n  return useQuery('groups', () =\u003e\n    axios.get('groups').then((response) =\u003e response.data)\n  );\n}\n```\n\n만약 위와같이 axios의 반환값을 그대로 useQuery에서 이용하게 된다면, 타입을 추론할 수 없고 fetch library에서 제공하는 타입을 그대로 인용하게 된다. 따라서 타입을 유추할 수 있도록 중간 layer function을 작성하여 이용하는 방법을 쓰는게 좋다.\n\n```jsx\nfunction fetchGroups(): Promise\u003cGroup[]\u003e {\n  return axios.get('groups').then((response) =\u003e response.data);\n}\n\n// ✅ data will be `Group[] | undefined` here\nfunction useGroups() {\n  return useQuery('groups', fetchGroups);\n}\n\n// ✅ data will be `number | undefined` here\nfunction useGroupCount() {\n  return useQuery('groups', fetchGroups, {\n    select: (groups) =\u003e groups.length,\n  });\n}\n```\n\n\u003e 타입 축소\n\n```jsx\nconst { data, isSuccess } = useGroups();\nif (isSuccess) {\n  // 🚨 data will still be `Group[] | undefined` here\n}\n\nconst groupsQuery = useGroups();\nif (groupsQuery.isSuccess) {\n  // ✅ groupsQuery.data will now be `Group[]`\n}\n```\n\n위의 방식처럼 destructuring을 사용하게 되면 type추론에서 undefined가 추가될 수 있다. 따라서 구조분해할당보단 객체를 그대로 가져와서 chaning을 이용하여 이용하는것이 타입의 범위를 축소할 수 있는 좋은 방법이다.\n\n# #8. 효과적인 React-Query key\n\n리액트쿼리에서 키는 중요 핵심개념으로, 라이브러리 내부적으로 데이터를 캐시하고, re-fetch를 하기 위해 필요한 개념이다.\n\n\u003e 데이터 캐싱\n\n쿼리 캐시는 직렬화된 쿼리키를 키로 하고, 데이터와 매터정보를 갖는 javascript object를 value로 갖도록 한다.\n\n이때, query key는 고유해야 하고, useQuery ↔ useInfiniteQuery에 동일한 쿼리키를 사용할 수 없다.\n\n```jsx\nuseQuery(['todos'], fetchTodos);\n\n// 🚨 this won't work\nuseInfiniteQuery(['todos'], fetchInfiniteTodos);\n\n// ✅ choose something else instead\nuseInfiniteQuery(['infiniteTodos'], fetchInfiniteTodos);\n```\n\n\u003e 자동 다시 가져오기\n\n```jsx\nfunction Component() {\n  const { data, refetch } = useQuery(['todos'], fetchTodos)\n\n  // ❓ how do I pass parameters to refetch ❓\n  return \u003cFilters onApply={() =\u003e refetch(???)} /\u003e\n}\n```\n\n위의 코드를 보면 finter에서 필터가 select되어 apply되는 시점에 todos를 해당 필터에 맞는 것들만 필터링하여 가져오길 원한다.\n\n그러나 apply에 refetch를 하도록 하는 방식은 적절하지 않다. todos에 해당하는 cache값은 이전과 언제나 동일하게 있을테니깐. (query key값은 그대로이므로)\n\n따라서 아래와 같이 변경해야 한다.\n\n```jsx\nfunction Component() {\n  const [filters, setFilters] = React.useState();\n  const { data } = useQuery(['todos', filters], () =\u003e fetchTodos(filters));\n\n  // ✅ set local state and let it \"drive\" the query\n  return \u003cFilters onApply={setFilters} /\u003e;\n}\n```\n\n\u003e 수동 상호 작용\n\n쿼리캐시에 대한 수동적인 상호작용을 이용하기 위해선 invalidateQueries, setQueriesData를 활용할 수 있다. 이때, query filter를 지원하기 때문에 filter 객체에 명시한 조건에 해당하는 쿼리들에 관하여 상호작용하도록 컨트롤 할 수 있다.\n\n\u003e 효과적인 쿼리 키\n\n- 도메인 별로 queries.ts로 파일 관리하도록 한다.\n- 쿼리키는 항상 배열로 만든다\n- 쿼리키 배열은 일반적인것 → 구체적인것 순서로 구체화하여 구조화 한다.\n- ## 쿼리 키 팩토리 사용\n  ```jsx\n  const todoKeys = {\n    all: ['todos'] as const,\n    lists: () =\u003e [...todoKeys.all, 'list'] as const,\n    list: (filters: string) =\u003e [...todoKeys.lists(), { filters }] as const,\n    details: () =\u003e [...todoKeys.all, 'detail'] as const,\n    detail: (id: number) =\u003e [...todoKeys.details(), id] as const,\n  }\n  ```\n\n\u003e QueryFunctionContext\n\n위의 todoKeys를 보면 쿼리키를 배열로 작성했다. 이때 QueryFunctionContext를 이용하면 입력된 queryKey를 구조분해 할당시\n\n```jsx\nconst todoKeys = {\n  all: ['todos'] as const,\n  lists: () =\u003e [...todoKeys.all, 'list'] as const,\n  list: (state: State, sorting: Sorting) =\u003e\n    [...todoKeys.lists(), state, sorting] as const,\n}\n\nconst fetchTodos = async ({\n  queryKey,\n}: // 🤯 only accept keys that come from the factory\nQueryFunctionContext\u003cReturnType\u003ctypeof todoKeys['list']\u003e\u003e) =\u003e {\n  const [, , state, sorting] = queryKey\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\n  return response.data\n}\n\nexport const useTodos = () =\u003e {\n  const { state, sorting } = useTodoParams()\n\n  // ✅ build the key via the factory\n  return useQuery(todoKeys.list(state, sorting), fetchTodos)\n}\n```\n\n콤마를 이용하여 불분명하게 구분해야만 한다.\n\n따라서 이러한 문제점을 해결하기 위해 쿼리키를 객체 형태로 만들어 사용하도록 하는 방법이 좋다.\n\n```jsx\nconst todoKeys = {\n  // ✅ all keys are arrays with exactly one object\n  all: [{ scope: 'todos' }] as const,\n  lists: () =\u003e [{ ...todoKeys.all[0], entity: 'list' }] as const,\n  list: (state: State, sorting: Sorting) =\u003e\n    [{ ...todoKeys.lists()[0], state, sorting }] as const,\n}\n\nconst fetchTodos = async ({\n  // ✅ extract named properties from the queryKey\n  queryKey: [{ state, sorting }],\n}: QueryFunctionContext\u003cReturnType\u003ctypeof todoKeys['list']\u003e\u003e) =\u003e {\n  const response = await axios.get(`todos/${state}?sorting=${sorting}`)\n  return response.data\n}\n\nexport const useTodos = () =\u003e {\n  const { state, sorting } = useTodoParams()\n\n  return useQuery(todoKeys.list(state, sorting), fetchTodos)\n}\n```\n\n# #9. 리액트 쿼리의 placeholder 및 init data\n\n리액트 쿼리에서 동기식으로 미리 값을 채우는 방식으로 두가지를 제공한다.\n\n- placeholder\n- initial data\n\n\u003e 유사점\n\n```jsx\nfunction Component() {\n  // ✅ status will be success even if we have not yet fetched data\n  const { data, status } = useQuery(['number'], fetchNumber, {\n    placeholderData: 23,\n  });\n\n  // ✅ same goes for initialData\n  const { data, status } = useQuery(['number'], fetchNumber, {\n    initialData: () =\u003e 42,\n  });\n}\n```\n\n두가지 모두 캐시에 해당 쿼리키로 값이 저장되어있다면, 아무런 역할을 하지 못한다.\n\n\u003e 차이점\n\n- initialData: cache수준에서 작동\n  - cache에 값이 저장된다.\n  - cache항목의 생성 순간( 첫번째 observer가 mount되는 시점 )에 값이 저장된다.\n- placeholder: observer수준에서 작동\n  - cache에 저장되지 않는다.\n  - 따라서 component마다 placeholder에 대한 값이 다를 수 있다\n\n\u003e 에러 처리\n\nbackground re-fetch가 실패했을 시\n\n- initialData\n  - 캐시엔 이미 initialData가 존배하므로 다른 background 오류와 같이 처리하면 된다.\n- placeholder\n  - cache에 데이터가 적재되려고 하는 순간 오류이므로 placeholder는 사라지고 cache엔 undefined가 저장된다.\n\n# 10. 상태관리자로서 react query\n\n\u003e 비동기 상태 관리자\n\nQueryClientProvider 하위에 존재하는 모든 component에선 queryClient를 통해 표출하는 모든 데이터는 observer로서 관찰이 가능하게 되며 해당 값의 변경을 자동으로 감지하여 rendering하게 되므로, 비동기 상태로 데이터를 관리하여 표출 가능하다.\n\n\u003e 데이터 동기화 도구\n\n리액트 쿼리의 cache데이터를 구독하는 component들은 cache에 저장된 snapshot성격의 데이터를 표시만 하는것이다. 따라서 해당 데이터가 stale 한지 fresh한지 판별하여 cache에 저장된 snapshot 데이터가 back-end와 동기화되도록 설정할 수 있다.\n\n- 리액트 쿼리 이전의 데이터 동기화\n  - 가져온 후 global로 저장하고, 업데이트 하지 않는다.\n- mount시마다 가져오고 component local에 한정\n  - useEffect(()⇒{}, []) 을 통해 가져온 데이터를 component local에서 이용한다.\n\n\u003e 데이터 재검증( 서버와 동기화 ) 하는동안 stale data 표출\n\n데이터를 서버로부터 새로 가져오는 과정은 시간이 걸리고, 화면에선 항상 loading bar || spinner가 표출되어야만 한다. 이것은 사용자 관점에서 “느리다\"는 느낌을 받게 하므로, fresh 데이터가 표출되기 전에 stale데이터가 먼저 표출되는것이 나을 수 있다.\n\n\u003e smart re-fetch\n\n- refetchOnMount\n  - mount시마다 재검증한다.\n- refetchOnWindowFocus\n  - 브라우저탭에 포커스를 할 때마다 re-fetch한다. 이게 너무 많다고 느낄 수 있으나, 사용자 관점에서 다른탭에 포커싱을 했다 해당 탭으로 돌아왔을때 fresh데이터를 표출해주는것은 사용자에게 최신의 데이터를 표시하는 완벽한 방법이다.\n- refetchOnReconnect\n  - 네트워크 연결 종료 후 fresh값을 표출해주는것 또한 화면의 값이 정확한지 여부를 다시 확인할 때 좋은 지표가 될 수 있다.\n\n만약 cache데이터를 바라보는 component를 다른 component의 하위 component로 넣을 경우 refetchOnMount를 켜놓게 되면 상위 컴포넌트 렌더링마다 하위 컴포넌트의 데이터를 계속해서 re-fetch하기 때문에 refetchOnMount를 끄는게 좋을 수 있다.\n\n\u003e staleTime 사용자 지정\n\n최신값을 표출하기 위한 목적으로 중복요청을 제거하기 위해 최소 20초 정도로 설정하는게 좋은 선택일 수 있다.\n\n이러한 설정들을 잡기위해 setQueryDefaults를 이용해 queryKey들의 기본설정을 지정할 수 있다.\n","fileName":"2024-01-28","route":"2024-01-28"},{"meta":{"title":"자바스크립트의 실행 컨텍스트","desc":"자바스크립트의 소스코드 평가 및 실행에 대한 설명","date":"2024.01.27","tags":["자바스크립트","javascript","context","자바스크립트 실행 컨텍스트"]},"content":"\n# 실행 컨텍스트\n\n\u003e 자바스크립트 소스코드의 4가지 타입\n\n1. 소스 코드 : 전역에 존재하는 소스코드( 함수, 클래스동의 내부 코드는 포함되지 않음 )\n2. 함수 코드 : 함수 내부에 존재하는 소스코드 ( 중첩 함수, 클래스 등의 코드는 포함되지 않음 )\n3. eval 코드 : eval에 전달되어 실행되는 소스코드\n4. 모듈 코드 : 모듈 내부에 존재하는 소스코드 ( 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않음 )\n\n\u003e 소스 코드\n\n전역 변수를 관리하기 위한 전역 스코프를 생성하고, 전역변수/함수 선언문 등을 전역 객체의 프로퍼티와 메서드로 바인딩 시킨다.\n\n\u003e 함수 코드\n\n지역 ㅅ코프를 생성하고, 지역변수, 매개변수, arguments객체를 관리한다.\n\n\u003e eval 코드\n\nstrict mode에서 자신만의 스코프를 생성하고 이를통해 실행 컨텍스트가 생성된다.\n\n\u003e 모듈 코드\n\n모듈별 독립적 모듈 스코프를 생성한다.\n\n모듈 코드가 평가되면 모듈의 실행 컨텍스트가 생성된다.\n\n# 자바스크립트의 소스코드 평가 및 실행\n\n자바스크립트의 실행은 크게 두 가지 과정이 있다.\n\n1. 소스코드 평가\n   1. 소스코드 평가 과정이 실행되면 먼저 실행 컨텍스트를 생성한다.\n   2. 변수 및 함수의 선언문만 먼저 실행하여 실행 컨텍스트가 관리하는 스코프( 렉시컬 환경 스코프 )에 등록한다.\n2. 소스코드의 실행\n   1. 소스코드 평가가 완료되면 선언문을 제외한 나머지 소스코드가 순차적으로 실행된다. ( = runtime)\n   2. 이때 필요한 실행정보(변수 및 함수 값)은 해당 스코프에서 취득한다.\n   3. 변수나 함수의 변경이 일어나면 해당 스코프의 변수/함수를 수정한다.\n\n# 자바스크립트 실행 컨텍스트의 역할\n\n1. 전역 코드 평가\n   1. 전역변수, 함수선언문을 전역 객체의 프로퍼티 및 메서드로 등록\n2. 전역 코드 실행\n   1. 함수가 호출되면 전역 코드 실행을 일시 중단하고, 함수 내부로 진입\n3. 함수 코드 평가\n   1. 함수의 코드를 평가하며 필요한 값들을 함수 내부 스코프에 등록\n4. 함수 코드 실행\n   1. 함수 코드 평가로 등록된 변수/함수들을 이용하여 코드를 실행한다.\n","fileName":"2024-01-27","route":"2024-01-27"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"kb4CdM01kABZ1Ms35zfwO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>