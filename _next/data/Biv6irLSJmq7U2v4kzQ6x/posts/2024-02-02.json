{"pageProps":{"prev":{"meta":{"title":"Rail 모델","desc":"브라우저 사용자 경험에 대한 지표 Rail모델","date":"2024.02.01","tags":["Rail","브라우저","렌더링","사용자 경험"]},"content":"\n# Rail 모델\n\n- Rail은 브라우저에서의 성능에 대해 생각할 수 있도록 해주는 사용주 중심 성능 모델\n- 4가지 웹앱의 생명주기를 통해 성능 지표를 나타냄(response, animation, idle, load)\n- 구체적 목표와 지침을 지정하여 성능 측정 항목으로 이용할 수 있도록 함\n\n![240203-210333](/posts/2024-02-01/240203-210333.png)\n\n출처: https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Rail모델에서 바라본 사용자 경험에 대한 기준\n\n| 0~16ms | - 사용자는 초당 60개의 프레임이 렌더링되는걸 부드럽다고 인식한다\n\n- 브라우저에서 새 프레임을 그리는데는 16ms가 걸린다.\n- | 사용자가 애니메이션이 매우 매끄럽다고 느낌 |\n  | ------------------------------------------ | ---------------------------------------------- |\n  | 0~100ms                                    | - 이 정도 응답에선 즉각적 반응이 일어난다 느낌 |\n- 하지만 더 길어지면 동작 ↔ 응답 이 끊어진다는 느낌을 받음 |\n  | 100~1,000ms | - 자연스럽고 지속적 작업의 일부로 받아들일 수 있는 수준\n- 대부분의 웹앱의 상태 |\n  | 1,000ms ~ 10,000ms | - 1초를 초과하므라 사용자는 작업에 집중을 잃게됨 |\n  | 10,000ms 이상 | - 사용자 이탈 |\n\n# Response: 50ms 미만의 이벤트 처리 목표\n\n- 목표 : 사용자 입력에 대한 interaction이 100ms이내에 완료되어 전달 될 수 있도록(즉각적이다는 느낌)\n- 지침\n  - 터치, 스크롤등 연결되는 동작은 제외하고, 클릭, 토글등의 이벤트에 적용\n  - 리소스가 많이 필요한 작업이라면 백그라운드로 동작할 수 있도록(사용자 경험을 차단하지 않도록)\n  - 50ms를 넘기는 응답에 대해선 피드백을 제공할 수 있도록한다.\n\n> 100ms 응답을 위해선 고작 50ms의 여유만 존재한다.\n\n목표가 100ms인 응답을 주려고 할 때, 개발자에게 가용한 시간은 50ms에 불과하다.\n\n목표하는 task처리외에도 입력에 대한 입력을 수용하고, 응답을 표출하기위한 처리시간 또한 필요하므로 실제 사용할 수 있는 시간은 50ms정도!\n\n![240203-210345](/posts/2024-02-01/240203-210345.png)\n\n출처 : https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Animation : 10ms안에 프레임 생성\n\n- 목표\n  - 애니메이션을 각 10ms 프레임 이하로 생성\n  - 각 프레임의 최대예산은 16ms지만 브라우저가 프레임을 렌더링하는 시간이 필요하므로 10ms만 가용\n  - 시각적 부드러움이 목표!\n- 지침\n  - 애니메이션 처리와 같이 높은 연산이 필요한 작업에는 다른 작업을 포함하지 않는다.\n  - 스크롤, 로드표시 와 같은 시각적 애니메이션등을 포함하는 개념들에 적용\n  - 렌더링 성능의 원리는 적극 참조한다.\n\n# Idle: 유휴시간 극대화\n\n- 목표\n  - idle time을 최대화하여 사용자의 입력에 50ms이내 응답할 수 있도록 한다.\n- 지침\n  - 초기 페이지 로드를 가볍게 하고, 유휴 시간에 나머지를 로드하도록 한다.\n  - 50ms를 넘는 작업은 다른 사용자 입력에 대한 응답에 방해가 될 수 있으므로, 그 이내 시간에 할 수 있도록 한다.\n  - 유휴 작업중 사용자 입력이 있다면, 우선순위에 따라 작동하도록 한다.\n\n# Load : 최대 5초 이내 콘텐츠 전달 후 상호작용 준비\n\n- 목표\n  - slow 3g상황에서도 5초 이내에 콘텐츠를 전달하고 상호작용에 준비할 수 있도록 한다.\n- ## 지침\n\n# Rail 측정도구\n\n- chrome devtools\n- Lighthouse\n- WebPageTest\n\n# Referrence\n","fileName":"2024-02-01","route":"2024-02-01"},"post":{"meta":{"title":"브라우저의 렌더링","desc":"브라우저의 렌더링 순서","date":"2024.02.02","tags":["브라우저","렌더링","CSSOM","AST"]},"content":"\n# 브라우저의 렌더링 순서\n\n1. HTML, CSS, Javascript, static files 등의 리소스를 요청 하고 응답 받는다.\n2. HTML, CSS를 파싱하여 DOM, CSSOM을 생성하여 렌더트리를 생성한다.\n   1. DOM 파싱\n      1. 서버에서 HTML을 바이트(2진수)형태로 응답받는다.\n      2. meta tag의 charset 어트리뷰트를 통해 인코딩 방식을 인식하고 해당 인코딩 방식으로 문자열 치환한다.\n      3. 해당 문자열을 문법적 최소 의미 단위를 갖는 토큰으로 분해한다.\n      4. 분해된 토큰을 기반으로 노드 객체를 생성한다.\n      5. 생성된 노드들은 트리구조로 되어있으며 이러한 구조를 DOM(Document Obejct Model)이라고 부른다.\n   2. CSSOM 파싱\n      1. DOM 생성( HTML 파싱 )중 link tag를 만나면 DOM 파싱을 중단한다.\n      2. link태그에 지정된 href 로 요청을 보내 css 파일을 다운로드 한다.\n      3. 다운받은 css파일을 DOM파싱과 동일한 과정을 거쳐 tree 구조의 객체들로 만들고 그것을 CSSOM(CSS Object Model)이라고 부른다.\n   3. 렌더트리\n      1. DOM과 CSSOM을 렌더트리로 결합한다.\n      2. 화면에 렌더링 되지 않는 태그( = script, link 및 css에 의해 비표출 되는 노드들)은 제외된다.\n      3. 생성된 렌더트리는 요소들의 레이아웃 계산에 사용되며 이를 통해 페인팅을 실행한다.\n3. 자바스크립트를 파싱하여 AST(Absctract Syntax Tree)를 생성하고, 바이트 코드로 변환하여 실행한다.\n   1. 자바스크립트의 파싱\n      1. DOM 생성 과정에서 script태그를 만나면 DOM 파싱을 중단하고 js를 파싱한다.\n      2. 파싱은 자바스크립트 엔진(V8, spiderMonkey, javaScriptCore 등)에서 일어난다.\n      3. 제어권을 넘겨받은 자바스크립트 엔진은 AST(Abstract Syntax Tree)를 생성한다.\n   2. 자바스크립트 소스 파싱의 순서\n      1. 토크나이징 : 토크나이저가 자바스크립트 소스를 토큰 단위로 분해한다.\n      2. 파싱 : 토큰들을 분석하여 AST를 생헌한다.\n      3. 바이트코드 생성 : AST를 인터프리터가 실행할 수 있는 바이트 코드로 변환 한다.\n         1. V8의 경우 자주 실행되는 코드는 터보팬(컴파일러)에 의해 Optimized Machine Code로 컴파일 되어 성능 최적화를 진행하며, 사용 빈도가 적어지만 Deoptimizing한다.\n      4. 실행 : 인터프리터가 바이트코드를 읽어 로직을 실행한다.\n4. 렌더트리를 기반으로 HTML요소의 레이아웃을 계산하고 브라우저 화면에 페인팅한다.\n\n### Reference\n\n- 자바스크립트 딥 다이브 (38장)\n","fileName":"2024-02-02","route":"2024-02-02"},"next":{"meta":{"title":"ShadowDOM에 대한 이해와 활용","desc":"ShadowDOM을 활용한 CSS 은닉과 그 활용","date":"2024.02.03","tags":["shadow dom","쉐도우 돔","css 은닉"]},"content":"\n# Shadow DOM이란 무엇인가?\n\n- cssom tree를 따로 가지는 html element\n- [shadowDOM mdn 설명 보러가기](https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_shadow_DOM)\n  ![240203-163855](/posts/2024-02-03/240203-163855.png)\n  그림1. shadowDOM cssom tree구조도 ( 출처: mdn)\n\n  > shadow dom을 활용하면 shadow dom 내/외부의 css가 서로 간섭없이 사용이 가능하다  \n  > 만약 특정 dom element가 내/외부 의 css와 연관없이 동작하도록 하고 싶다면 shadowDOM을 활용하면 된다\n\n  ```javascript\n  const openShadowRoot = (dom: HTMLElement) => {\n    if (dom?.shadowRoot) return dom.shadowRoot;\n    const shadowRoot = dom.attachSadow({\n      mode: 'open',\n    });\n    return shadowRoot;\n  };\n\n  const shadowRoot = openShadowRoot(document.querySelector('#root'));\n  console.log(shadowRoot);\n  ```\n\n  위와같이 shadow DOM으로 활용하고자 하는 dom element에 attachShadow를 해주면\n  shadow-root가 오픈된다.\n  ![240203-164510](/posts/2024-02-03/240203-164510.png)\n  ![240203-164702](/posts/2024-02-03/240203-164702.png)\n\n  <hr />\n\n  ## shadowDOM의 활용 ( React )\n\n  이렇게 만든 shadowDOM을 리액트 환경에서 한번 활용해보자\n\n```typescript\n// ShadowDOM.tsx\nimport { ReactNode, useRef, useState, ReactPortal, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport default function ShadowDOM({ children }: { children?: ReactNode }) {\n  const divRef = useRef<HTMLDivElement>(null);\n  const [portal, setPortal] = useState<ReactPortal | null>(null);\n\n  useEffect(() => {\n    if (!divRef.current || divRef?.current?.shadowRoot) return;\n    const shadowRoot =\n      divRef?.current?.shadowRoot ??\n      divRef.current.attachShadow({ mode: 'open' });\n    const _portal = createPortal(children, shadowRoot);\n    setPortal(_portal as ReactPortal);\n  }, [children]);\n\n  return <div ref={divRef}>{portal}</div>;\n}\n\n// Home.tsx\nimport ShadowDOM from '@/components/common/ShadowDOM';\n\nexport default function Home() {\n  return (\n    <ShadowDOM>\n      <style>\n        {'div { background-color: red; width: 200px; height: 300px;}'}\n      </style>\n      <div>home</div>\n    </ShadowDOM>\n  );\n}\n```\n\n![240203-182312](/posts/2024-02-03/240203-182312.png)\n![240203-182137](/posts/2024-02-03/240203-182137.png)\n\n위와같이 home 컴포넌트의 background-color가 외부에 전파되지 않는것을 확인할 수 있다.\n\n<iframe\n  width='300'\n  height='400'\n  src='/home'\n  frameborder='0'\n  allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\n  allowfullscreen></iframe>\n예시1. shadowDOM을 통한 css 은닉 화면 (iframe)\n","fileName":"2024-02-03","route":"2024-02-03"}},"__N_SSG":true}