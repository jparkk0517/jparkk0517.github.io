{"pageProps":{"prev":{"meta":{"title":"GraphQL은 무엇인가","desc":"GraphQL에 대한 공부","date":"2024.01.29","tags":["Graph QL","그래프 큐엘"]},"content":"\n> GraphQL이란\n\n<aside>\n💡 GraphQL은 쿼리언어이자 서버측 런타임\n\n</aside>\n\n그래프 큐엘은 데이터를 가져오는데 쿼리를 이용하도록 합니다.\n\n> runtime\n\ngraphQL api는 서버에서 runtime에 실행된다.\n\n데이터의 출처에 구애받지 않고 runtime에 데이터 패칭이 가능하다.\n\n> GraphQL 구현 순서\n\n1. GraphQL schema design\n2. resolver ↔ data source connection\n3. GraphQL query fetching\n\n> GraphQL 의 특징\n\n1. 성능\n   1. 오버패칭 방지\n   2. 언더패칭 방지: rest API의 경우 서로 다른 schema 또는 data source의 경우 여러번의 api콜로 각각 언더패칭된 데이터를 front-side에서 조합해야 하는 경우가 있다. graphQL은 이런 문제를 해결해준다.\n2. 개발자 편의성\n   1. 계층적 스키마 구조: 그래프 구조와 선언적 구조를 통해 쿼리를 직관적으로 이해할 수 있다.\n   2. 타입 안정성: graphQL은 그 자체로 스키마 구조를 가지므로 프론트 사이드와 서버 사이드의 타입이 상호 동일해야만 통신이 가능하므로 그 자체로 타입안정성을 보장한다.\n3. 구조\n   1. 클라이언트 개발의 서버 의존성 분리: restAPI처럼 서버사이드에서 원하는 API를 개발해 줄 때까지 기다려야 하는 업무의존성을 없앨 수 있다.\n   2. 단일 정보출처: 프론트 사이드에선 데이터들 마다 API를 언더패칭하여 조합하던 restAPI와 달리 조합이 되어 불려오도록 하는 단일 출처만 알면된다.\n4. 훌륭한 커뮤니티\n   1. 훌륭한 도구들: apollo client, apollo studio 등 다양한 도구들이 완비되어있다.\n   2. 광범위한 이용: 여러 사이트 들에서 graphQL을 이용중이다.\n","fileName":"2024-01-29","route":"2024-01-29"},"post":{"meta":{"title":"V8엔진 구동 순서","desc":"V8엔진의 구동 순서에 대한 공부","date":"2024.01.30","tags":["V8","AST","브라우저"]},"content":"\n> v8엔진 구동 순서\n\n1. 소스코드 파싱\n2. AST(Abstract Syntax Tree) 추상 구문 트리로 변환 → 컴파일러들이 이용하는 자료구조\n3. 자바스크립트 바이트코드로 변환(인터프리터 Ignition 이용)\n   1. Ignition : v8부터 이용되는 인터프리터로 이전의 Full-codegen(인터프리터)를 대체한다.\n\n      (인터프리터 : 소스코드를 바로 실행하는 환경 )\n4. 바이트 코드 실행\n   1. 자주 사용하는 코드는 TurboFan으로 보내 최적화된 코드로 재컴파일(Optimized Machine Code)\n   2. 사용률이 떨어지면 deoptimized\n5.\n\n> 레퍼런스\n\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n","fileName":"2024-01-30","route":"2024-01-30"},"next":{"meta":{"title":"DOM","desc":"Document Object Model에 대한 공부","date":"2024.01.31","tags":["DOM","Document Object Model"]},"content":"\n# 노드\n\n> HTML요소와 노드 객체\n\n- HTML요소 : HTML문서를 구성하는 개별 요소\n  - HTML요소의 구조\n    - 시작태그(start tag)\n    - 어트리뷰트 명 (attribute name)\n    - 어트리뷰트 값 (attribute value)\n    - 콘텐츠 (contents)\n- HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.\n\n> 노드 타입의 종류\n\n- 문서 노드( document node )\n  - DOM트리 최상에 존재하는 루트 노드\n  - document 객체를 가리킨다.\n- 요소 노드 (element node)\n  - HTML요소를 가리키는 객체\n- 어트리뷰트 노드 (attribute node)\n  - HTML요소의 attribute를 가리키는 객체\n  - HTML 요소 노드의 sibling관계를 갖는다.\n  - 부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.\n- 텍스트 노드 (text node)\n  - element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드\n\n> 노드 객체의 상속구조\n\n노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.\n\n노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.\n\n![240203-210458](/posts/2024-01-31/240203-210458.png)\n\n그림. 노드객체의 상속구조(구글 검색)\n\n위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.\n\n이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.\n\n```jsx\nconst input = document.createElement('input');\n/*\n\t최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위\n*/\n```\n\n> Element node의 텍스트 조작\n\n1. nodeValue\n\n   1. nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.\n\n   ```jsx\n   <div id='text'>hello</div>;\n   const hello = document.querySelector('#text');\n   console.log(hello.nodeValue); // null\n   console.log(hello.firstChild.nodeValue); // hello\n   ```\n\n2. textContent\n\n   1. getter와 setter가 모두 존재하는 접근자 프로퍼티.\n   2. textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)\n   3. ```jsx\n      <div id='text'>\n        hello <span>world</span>\n      </div>;\n      const hello = document.querySelector('#text');\n      console.log(hello.textContent); // hello world\n      ```\n\n   4. element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.\n   5. innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.\n      1. innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.\n      2. css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.\n\n   > 어트리뷰트\n\n   HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.\n\n   - HTML어트리뷰트 vs DOM프로퍼티\n     - 어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.\n     - 따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.\n     - ![240203-210509](/posts/2024-01-31/240203-210509.png)\n     - DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!\n   - HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계\n     - id attribute 와 id property 는 1대1대응\n     - value attribute ⇒ 초깃값, value property ⇒ 최신값\n     - class attribute ⇒ className, classList와 대응\n     - for attribute ⇒ htmlFor 프로퍼티와 1대1 대응\n     - td요소의 colspan attribute는 대응하는 프로퍼티 없음\n     - textContent 프로퍼티는 대응하는 어트리뷰트 없음\n     - attribute는 대소문자x, property는 카멜케이스\n     -\n\n# 레퍼런스\n\n1. 모던 자바스크립트 deep dive(p.677)\n","fileName":"2024-01-31","route":"2024-01-31"}},"__N_SSG":true}