{"pageProps":{"post":{"meta":{"title":"ShadowDOM에 대한 이해와 활용","desc":"ShadowDOM을 활용한 CSS 은닉과 그 활용","date":"2024.02.03","tags":["shadow dom","쉐도우 돔","css 은닉"]},"content":"\n# Shadow DOM이란 무엇인가?\n\n- cssom tree를 따로 가지는 html element\n- [shadowDOM mdn 설명 보러가기](https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_shadow_DOM)\n  ![240203-163855](/posts/2024-02-03/240203-163855.png)\n  그림1. shadowDOM cssom tree구조도 ( 출처: mdn)\n\n  > shadow dom을 활용하면 shadow dom 내/외부의 css가 서로 간섭없이 사용이 가능하다  \n  > 만약 특정 dom element가 내/외부 의 css와 연관없이 동작하도록 하고 싶다면 shadowDOM을 활용하면 된다\n\n  ```javascript\n  const openShadowRoot = (dom: HTMLElement) => {\n    if (dom?.shadowRoot) return dom.shadowRoot;\n    const shadowRoot = dom.attachSadow({\n      mode: 'open',\n    });\n    return shadowRoot;\n  };\n\n  const shadowRoot = openShadowRoot(document.querySelector('#root'));\n  console.log(shadowRoot);\n  ```\n\n  위와같이 shadow DOM으로 활용하고자 하는 dom element에 attachShadow를 해주면\n  shadow-root가 오픈된다.\n  ![240203-164510](/posts/2024-02-03/240203-164510.png)\n  ![240203-164702](/posts/2024-02-03/240203-164702.png)\n\n  <hr />\n\n  ## shadowDOM의 활용 ( React )\n\n  이렇게 만든 shadowDOM을 리액트 환경에서 한번 활용해보자\n\n```typescript\n// ShadowDOM.tsx\nimport { ReactNode, useRef, useState, ReactPortal, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport default function ShadowDOM({ children }: { children?: ReactNode }) {\n  const divRef = useRef<HTMLDivElement>(null);\n  const [portal, setPortal] = useState<ReactPortal | null>(null);\n\n  useEffect(() => {\n    if (!divRef.current || divRef?.current?.shadowRoot) return;\n    const shadowRoot =\n      divRef?.current?.shadowRoot ??\n      divRef.current.attachShadow({ mode: 'open' });\n    const _portal = createPortal(children, shadowRoot);\n    setPortal(_portal as ReactPortal);\n  }, [children]);\n\n  return <div ref={divRef}>{portal}</div>;\n}\n\n// Home.tsx\nimport ShadowDOM from '@/components/common/ShadowDOM';\n\nexport default function Home() {\n  return (\n    <ShadowDOM>\n      <style>\n        {'div { background-color: red; width: 200px; height: 300px;}'}\n      </style>\n      <div>home</div>\n    </ShadowDOM>\n  );\n}\n```\n\n![240203-182312](/posts/2024-02-03/240203-182312.png)\n![240203-182137](/posts/2024-02-03/240203-182137.png)\n\n위와같이 home 컴포넌트의 background-color가 외부에 전파되지 않는것을 확인할 수 있다.\n\n<iframe\n  width='300'\n  height='400'\n  src='/home'\n  frameborder='0'\n  allow='accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture'\n  allowfullscreen></iframe>\n예시1. shadowDOM을 통한 css 은닉 화면 (iframe)\n","fileName":"2024-02-03","route":"2024-02-03"},"prev":{"meta":{"title":"브라우저의 렌더링","desc":"브라우저의 렌더링 순서","date":"2024.02.02","tags":["브라우저","렌더링","CSSOM","AST"]},"content":"\n# 브라우저의 렌더링 순서\n\n1. HTML, CSS, Javascript, static files 등의 리소스를 요청 하고 응답 받는다.\n2. HTML, CSS를 파싱하여 DOM, CSSOM을 생성하여 렌더트리를 생성한다.\n   1. DOM 파싱\n      1. 서버에서 HTML을 바이트(2진수)형태로 응답받는다.\n      2. meta tag의 charset 어트리뷰트를 통해 인코딩 방식을 인식하고 해당 인코딩 방식으로 문자열 치환한다.\n      3. 해당 문자열을 문법적 최소 의미 단위를 갖는 토큰으로 분해한다.\n      4. 분해된 토큰을 기반으로 노드 객체를 생성한다.\n      5. 생성된 노드들은 트리구조로 되어있으며 이러한 구조를 DOM(Document Obejct Model)이라고 부른다.\n   2. CSSOM 파싱\n      1. DOM 생성( HTML 파싱 )중 link tag를 만나면 DOM 파싱을 중단한다.\n      2. link태그에 지정된 href 로 요청을 보내 css 파일을 다운로드 한다.\n      3. 다운받은 css파일을 DOM파싱과 동일한 과정을 거쳐 tree 구조의 객체들로 만들고 그것을 CSSOM(CSS Object Model)이라고 부른다.\n   3. 렌더트리\n      1. DOM과 CSSOM을 렌더트리로 결합한다.\n      2. 화면에 렌더링 되지 않는 태그( = script, link 및 css에 의해 비표출 되는 노드들)은 제외된다.\n      3. 생성된 렌더트리는 요소들의 레이아웃 계산에 사용되며 이를 통해 페인팅을 실행한다.\n3. 자바스크립트를 파싱하여 AST(Absctract Syntax Tree)를 생성하고, 바이트 코드로 변환하여 실행한다.\n   1. 자바스크립트의 파싱\n      1. DOM 생성 과정에서 script태그를 만나면 DOM 파싱을 중단하고 js를 파싱한다.\n      2. 파싱은 자바스크립트 엔진(V8, spiderMonkey, javaScriptCore 등)에서 일어난다.\n      3. 제어권을 넘겨받은 자바스크립트 엔진은 AST(Abstract Syntax Tree)를 생성한다.\n   2. 자바스크립트 소스 파싱의 순서\n      1. 토크나이징 : 토크나이저가 자바스크립트 소스를 토큰 단위로 분해한다.\n      2. 파싱 : 토큰들을 분석하여 AST를 생헌한다.\n      3. 바이트코드 생성 : AST를 인터프리터가 실행할 수 있는 바이트 코드로 변환 한다.\n         1. V8의 경우 자주 실행되는 코드는 터보팬(컴파일러)에 의해 Optimized Machine Code로 컴파일 되어 성능 최적화를 진행하며, 사용 빈도가 적어지만 Deoptimizing한다.\n      4. 실행 : 인터프리터가 바이트코드를 읽어 로직을 실행한다.\n4. 렌더트리를 기반으로 HTML요소의 레이아웃을 계산하고 브라우저 화면에 페인팅한다.\n\n### Reference\n\n- 자바스크립트 딥 다이브 (38장)\n","fileName":"2024-02-02","route":"2024-02-02"},"next":null},"__N_SSG":true}