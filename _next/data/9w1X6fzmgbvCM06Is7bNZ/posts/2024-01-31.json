{"pageProps":{"post":{"meta":{"title":"DOM","desc":"Document Object Model에 대한 공부","date":"2024.01.31","tags":["DOM","Document Object Model"]},"content":"\n# 노드\n\n> HTML요소와 노드 객체\n\n- HTML요소 : HTML문서를 구성하는 개별 요소\n  - HTML요소의 구조\n    - 시작태그(start tag)\n    - 어트리뷰트 명 (attribute name)\n    - 어트리뷰트 값 (attribute value)\n    - 콘텐츠 (contents)\n- HTML 문서는 HTML요소들의 집합으로 이루어지며, 요소들은 중첩관계에 의한 부자 관계가 형성된다.\n\n> 노드 타입의 종류\n\n- 문서 노드( document node )\n  - DOM트리 최상에 존재하는 루트 노드\n  - document 객체를 가리킨다.\n- 요소 노드 (element node)\n  - HTML요소를 가리키는 객체\n- 어트리뷰트 노드 (attribute node)\n  - HTML요소의 attribute를 가리키는 객체\n  - HTML 요소 노드의 sibling관계를 갖는다.\n  - 부모 노드에 직접 연결되지 않고, element node에 형제 요소로 연결되어 있다. 따라서 attbitute 노드에 접근하려면 항상 element node를 타고 들어와야 한다.\n- 텍스트 노드 (text node)\n  - element node의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드\n\n> 노드 객체의 상속구조\n\n노드객체는 HTML문서의 계층적 구조를 표현하는데 사용되는 객체로, DOM을 구성하며, DOM API를 통해 자신의 구조나 정보를 변경할 수 있다.\n\n노드 객체는 ECMAScript 표준 사항이지만 자바스크립트의 빌트인 객체는 아니다. browser runtime환경에서 제공되는 browser 전용 host객체로 분류된다.\n\n![240203-210458](/posts/2024-01-31/240203-210458.png)\n\n그림. 노드객체의 상속구조(구글 검색)\n\n위 그림에서 가장 우측에 있는 요소 객체들은 object~ HTMLElement까지 이뤄지는 모든 인터페이스들을 상속하는 요소 객체로 상위에 있는 모든 요소들의 특성을 이용할 수 있다.\n\n이렇게 상속구조화 된 node를 이용하여 DOM객체를 생성하고 DOM Api를 통해 HTML의 내용이나 구조, 스타일등을 동적으로 변경할 수 있도록 해준다.\n\n```jsx\nconst input = document.createElement('input');\n/*\n\t최하위 node element인 HTMLInputElement를 통해 DOM객체를 생성하고 input이라는 변수에 담은 행위\n*/\n```\n\n> Element node의 텍스트 조작\n\n1. nodeValue\n\n   1. nodeValue는 node의 텍스트 노드(리프노드)의 value를 반환하는 api다.\n\n   ```jsx\n   <div id='text'>hello</div>;\n   const hello = document.querySelector('#text');\n   console.log(hello.nodeValue); // null\n   console.log(hello.firstChild.nodeValue); // hello\n   ```\n\n2. textContent\n\n   1. getter와 setter가 모두 존재하는 접근자 프로퍼티.\n   2. textContent를 이용하면 element node 의 contents영역에 있는 모든 text를 반환한다.(마크업은 무t시)\n   3. ```jsx\n      <div id='text'>\n        hello <span>world</span>\n      </div>;\n      const hello = document.querySelector('#text');\n      console.log(hello.textContent); // hello world\n      ```\n\n   4. element node의 textContent에 문자열을 할당해버리면 contents영역 전체가 해당 문자열로 치환되어버린다.\n   5. innerText가 textContent와 유사하게 동작하지만 아래와 같은 이유로 잘 사용하지 않는다.\n      1. innerText는css에 순종적이다 예를 들어 css에 의한 비표시(visibility : hidden)의 경우 값을 반환하지 않는다.\n      2. css에 대한 탐색까지 이루어져야 하므로 textContent보다 느리다.\n\n   > 어트리뷰트\n\n   HTML이 파싱될 때, HTML요소의 어트리뷰트들은 어트리뷰트 노드로 변환되어 요소 노드의 형제 노드로 추가된다.\n\n   - HTML어트리뷰트 vs DOM프로퍼티\n     - 어트리뷰트 노드 또한 DOM 객체로 생성되며 이때 어트리뷰트 노드들은 해당 DOM의 프로퍼티로 지정되고, 이 프로퍼티들은 초깃값으로 어트리뷰트의 값을 갖는다.\n     - 따라서 DOM 프로퍼티에 값을 할당해도 어트리뷰트 노드의 값은 바뀌지 않는다.\n     - ![240203-210509](/posts/2024-01-31/240203-210509.png)\n     - DOM 프로퍼티에 값을 할당한다는것은 HTML요소의 최신 상태값을 변경하는것!\n   - HTML 어트리뷰트 ↔ DOM 프로퍼티의 대응관계\n     - id attribute 와 id property 는 1대1대응\n     - value attribute ⇒ 초깃값, value property ⇒ 최신값\n     - class attribute ⇒ className, classList와 대응\n     - for attribute ⇒ htmlFor 프로퍼티와 1대1 대응\n     - td요소의 colspan attribute는 대응하는 프로퍼티 없음\n     - textContent 프로퍼티는 대응하는 어트리뷰트 없음\n     - attribute는 대소문자x, property는 카멜케이스\n     -\n\n# 레퍼런스\n\n1. 모던 자바스크립트 deep dive(p.677)\n","fileName":"2024-01-31","route":"2024-01-31"},"prev":{"meta":{"title":"V8엔진 구동 순서","desc":"V8엔진의 구동 순서에 대한 공부","date":"2024.01.30","tags":["V8","AST","브라우저"]},"content":"\n> v8엔진 구동 순서\n\n1. 소스코드 파싱\n2. AST(Abstract Syntax Tree) 추상 구문 트리로 변환 → 컴파일러들이 이용하는 자료구조\n3. 자바스크립트 바이트코드로 변환(인터프리터 Ignition 이용)\n   1. Ignition : v8부터 이용되는 인터프리터로 이전의 Full-codegen(인터프리터)를 대체한다.\n\n      (인터프리터 : 소스코드를 바로 실행하는 환경 )\n4. 바이트 코드 실행\n   1. 자주 사용하는 코드는 TurboFan으로 보내 최적화된 코드로 재컴파일(Optimized Machine Code)\n   2. 사용률이 떨어지면 deoptimized\n5.\n\n> 레퍼런스\n\n- https://evan-moon.github.io/2019/06/28/v8-analysis/\n","fileName":"2024-01-30","route":"2024-01-30"},"next":{"meta":{"title":"Rail 모델","desc":"브라우저 사용자 경험에 대한 지표 Rail모델","date":"2024.02.01","tags":["Rail","브라우저","렌더링","사용자 경험"]},"content":"\n# Rail 모델\n\n- Rail은 브라우저에서의 성능에 대해 생각할 수 있도록 해주는 사용주 중심 성능 모델\n- 4가지 웹앱의 생명주기를 통해 성능 지표를 나타냄(response, animation, idle, load)\n- 구체적 목표와 지침을 지정하여 성능 측정 항목으로 이용할 수 있도록 함\n\n![240203-210333](/posts/2024-02-01/240203-210333.png)\n\n출처: https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Rail모델에서 바라본 사용자 경험에 대한 기준\n\n| 0~16ms | - 사용자는 초당 60개의 프레임이 렌더링되는걸 부드럽다고 인식한다\n\n- 브라우저에서 새 프레임을 그리는데는 16ms가 걸린다.\n- | 사용자가 애니메이션이 매우 매끄럽다고 느낌 |\n  | ------------------------------------------ | ---------------------------------------------- |\n  | 0~100ms                                    | - 이 정도 응답에선 즉각적 반응이 일어난다 느낌 |\n- 하지만 더 길어지면 동작 ↔ 응답 이 끊어진다는 느낌을 받음 |\n  | 100~1,000ms | - 자연스럽고 지속적 작업의 일부로 받아들일 수 있는 수준\n- 대부분의 웹앱의 상태 |\n  | 1,000ms ~ 10,000ms | - 1초를 초과하므라 사용자는 작업에 집중을 잃게됨 |\n  | 10,000ms 이상 | - 사용자 이탈 |\n\n# Response: 50ms 미만의 이벤트 처리 목표\n\n- 목표 : 사용자 입력에 대한 interaction이 100ms이내에 완료되어 전달 될 수 있도록(즉각적이다는 느낌)\n- 지침\n  - 터치, 스크롤등 연결되는 동작은 제외하고, 클릭, 토글등의 이벤트에 적용\n  - 리소스가 많이 필요한 작업이라면 백그라운드로 동작할 수 있도록(사용자 경험을 차단하지 않도록)\n  - 50ms를 넘기는 응답에 대해선 피드백을 제공할 수 있도록한다.\n\n> 100ms 응답을 위해선 고작 50ms의 여유만 존재한다.\n\n목표가 100ms인 응답을 주려고 할 때, 개발자에게 가용한 시간은 50ms에 불과하다.\n\n목표하는 task처리외에도 입력에 대한 입력을 수용하고, 응답을 표출하기위한 처리시간 또한 필요하므로 실제 사용할 수 있는 시간은 50ms정도!\n\n![240203-210345](/posts/2024-02-01/240203-210345.png)\n\n출처 : https://web.dev/rail/#response-process-events-in-under-50ms\n\n# Animation : 10ms안에 프레임 생성\n\n- 목표\n  - 애니메이션을 각 10ms 프레임 이하로 생성\n  - 각 프레임의 최대예산은 16ms지만 브라우저가 프레임을 렌더링하는 시간이 필요하므로 10ms만 가용\n  - 시각적 부드러움이 목표!\n- 지침\n  - 애니메이션 처리와 같이 높은 연산이 필요한 작업에는 다른 작업을 포함하지 않는다.\n  - 스크롤, 로드표시 와 같은 시각적 애니메이션등을 포함하는 개념들에 적용\n  - 렌더링 성능의 원리는 적극 참조한다.\n\n# Idle: 유휴시간 극대화\n\n- 목표\n  - idle time을 최대화하여 사용자의 입력에 50ms이내 응답할 수 있도록 한다.\n- 지침\n  - 초기 페이지 로드를 가볍게 하고, 유휴 시간에 나머지를 로드하도록 한다.\n  - 50ms를 넘는 작업은 다른 사용자 입력에 대한 응답에 방해가 될 수 있으므로, 그 이내 시간에 할 수 있도록 한다.\n  - 유휴 작업중 사용자 입력이 있다면, 우선순위에 따라 작동하도록 한다.\n\n# Load : 최대 5초 이내 콘텐츠 전달 후 상호작용 준비\n\n- 목표\n  - slow 3g상황에서도 5초 이내에 콘텐츠를 전달하고 상호작용에 준비할 수 있도록 한다.\n- ## 지침\n\n# Rail 측정도구\n\n- chrome devtools\n- Lighthouse\n- WebPageTest\n\n# Referrence\n","fileName":"2024-02-01","route":"2024-02-01"}},"__N_SSG":true}